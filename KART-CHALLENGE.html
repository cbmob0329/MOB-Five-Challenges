<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Runner – cone + contena + trampoline + gomi</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{ --stage-w:390px; --stage-h:700px; }
  html,body{height:100%;margin:0;background:#000;color:#fff;overscroll-behavior:none}
  #root{position:fixed;inset:0;display:grid;place-items:center}
  #phone{
    width:var(--stage-w);height:var(--stage-h);position:relative;overflow:hidden;
    background:#070b12;border:1px solid #0e1522;border-radius:16px;box-shadow:0 12px 40px rgba(0,0,0,.45);
    transform-origin:center center;
  }
  /* HUD（固定） */
  header.hud{
    position:absolute;left:0;right:0;top:env(safe-area-inset-top);height:56px;z-index:20;
    display:flex;gap:10px;align-items:center;justify-content:space-around;padding:8px 10px;
    background:linear-gradient(180deg,rgba(12,18,28,.9),rgba(10,14,22,.8)); border-bottom:1px solid rgba(255,255,255,.06);
    font:600 12px/1 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif;
  }
  .pill{background:#11192a;border:1px solid rgba(255,255,255,.08);padding:6px 10px;border-radius:999px}

  /* プレイ領域（HUD/ボタンと分離） */
  main.play{position:absolute;left:0;right:0;top:56px;bottom:96px}
  canvas#game{width:100%;height:100%;display:block;image-rendering:pixelated;background:transparent}

  /* 操作ボタン（固定） */
  footer.ctrl{
    position:absolute;left:0;right:0;bottom:env(safe-area-inset-bottom);height:96px;z-index:20;
    display:flex;gap:12px;align-items:center;justify-content:center;padding:10px 12px;
    background:linear-gradient(180deg,rgba(10,14,22,.8),rgba(7,10,16,.95)); border-top:1px solid rgba(255,255,255,.06);
  }
  .btn{-webkit-tap-highlight-color:transparent; user-select:none; touch-action:manipulation;
    min-width:120px;padding:12px 16px;border-radius:14px;border:1px solid rgba(255,255,255,.1);
    background:#182233;font-weight:800;color:#fff;box-shadow:0 6px 20px rgba(0,0,0,.35);font-size:16px}
  .btn:active{transform:translateY(1px)}
  .muted{opacity:.6;filter:saturate(.2)}

  /* キャラ選択 */
  #overlay{position:absolute;inset:56px 0 96px;display:none;place-items:center;z-index:30;background:rgba(0,0,0,.35)}
  .card{width:min(92%,360px);background:#0c121f;border:1px solid rgba(255,255,255,.1);border-radius:16px;padding:16px}
  .choices{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .choice{display:grid;gap:8px;justify-items:center;background:#111a2a;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px;cursor:pointer}
  .choice img{width:72px;height:72px;object-fit:contain;background:#0b0f18;border-radius:10px;border:1px solid rgba(255,255,255,.06)}

  /* ローディング／ゲームオーバー */
  #loading{position:absolute;inset:56px 0 96px;display:grid;place-items:center;z-index:40;background:rgba(0,0,0,.6)}
  .bubble{padding:10px 14px;border-radius:12px;background:#111a2a;border:1px solid rgba(255,255,255,.08);font-size:13px}
  #gameover{position:absolute;inset:56px 0 96px;display:none;place-items:center;z-index:50;background:rgba(0,0,0,.6)}
  #gameover .panel{background:#0c121f;border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:16px;display:grid;gap:10px;justify-items:center;color:#fff;font:800 24px/1 system-ui}
</style>
</head>
<body>
<div id="root">
  <div id="phone">
    <header class="hud">
      <div class="pill" id="dist">距離 0 m</div>
      <div class="pill" id="speed">速度 0 km/h</div>
      <div class="pill" id="jump">ジャンプ 2</div>
      <div class="pill">BOOST <span id="boostPct">100%</span></div>
    </header>

    <main class="play"><canvas id="game" width="390" height="540"></canvas></main>

    <footer class="ctrl">
      <button class="btn" id="btnJump">ジャンプ</button>
      <button class="btn" id="btnBoost">BOOST!</button>
    </footer>

    <div id="overlay">
      <div class="card">
        <p style="margin:0 0 8px;font-weight:800;">どちらか選択してスタート</p>
        <div class="choices">
          <div class="choice" data-char="VR"><img src="VR.png" alt="VR"><small>VR.png</small></div>
          <div class="choice" data-char="orange"><img src="orange.png" alt="orange"><small>orange.png</small></div>
        </div>
      </div>
    </div>

    <div id="loading"><div class="bubble">画像読み込み中…</div></div>

    <div id="gameover">
      <div class="panel">
        <div>GAME OVER</div>
        <button class="btn" id="retryBtn">リトライ</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  /* ===== PCでもスマホ画角のまま表示 ===== */
  const phone=document.getElementById('phone');
  function fit(){ const s=Math.min(innerWidth/390, innerHeight/700); phone.style.transform=`scale(${s})`; }
  addEventListener('resize', fit, {passive:true}); fit();

  /* ===== Canvas 基本 ===== */
  const cvs=document.getElementById('game'), ctx=cvs.getContext('2d',{alpha:true});
  ctx.imageSmoothingEnabled=false; const W=390, H=540;
  function setup(){ const dpr=Math.max(1,devicePixelRatio||1); cvs.width=W*dpr; cvs.height=H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); }
  setup(); addEventListener('resize', setup, {passive:true});

  const overlay=document.getElementById('overlay'), loading=document.getElementById('loading'), gameover=document.getElementById('gameover');

  /* ===== 画像プリロード ===== */
  function load(src){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }
  Promise.all([
    load('sora.png'), load('mob.png'),
    load('corn.png'), load('contena.png'), load('tora.png'), load('gomi.png'),
    load('VR.png').catch(()=>null), load('orange.png').catch(()=>null),
  ]).then(([IMG_BG, IMG_GR, IMG_CO, IMG_CT, IMG_TR, IMG_GO, IMG_VR, IMG_OR])=>{

    /* ==== ピクセルユーティリティ ==== */
    const Px = {
      topTrim(img){ const w=img.naturalWidth,h=img.naturalHeight,c=document.createElement('canvas'); c.width=w;c.height=h;
        const g=c.getContext('2d',{willReadFrequently:true}); g.drawImage(img,0,0);
        const d=g.getImageData(0,0,w,h).data,TH=12;
        for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ if(d[(y*w+x)*4+3]>TH) return {trimTop:y,contentH:h-y}; } }
        return {trimTop:0,contentH:h};
      },
      bottomTrim(img){ const w=img.naturalWidth,h=img.naturalHeight,c=document.createElement('canvas'); c.width=w;c.height=h;
        const g=c.getContext('2d',{willReadFrequently:true}); g.drawImage(img,0,0);
        const d=g.getImageData(0,0,w,h).data,TH=12;
        for(let y=h-1;y>=0;y--){ for(let x=0;x<w;x++){ if(d[(y*w+x)*4+3]>TH) return {bottomTrim:h-1-y,h}; } }
        return {bottomTrim:0,h};
      },
      tightRect(img){ const w=img.naturalWidth,h=img.naturalHeight,c=document.createElement('canvas'); c.width=w;c.height=h;
        const g=c.getContext('2d',{willReadFrequently:true}); g.drawImage(img,0,0);
        const d=g.getImageData(0,0,w,h).data,TH=12; let minX=w,minY=h,maxX=-1,maxY=-1;
        for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ if(d[(y*w+x)*4+3]>TH){ if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y; } } }
        if(maxX<0) return {sx:0,sy:0,sw:w,sh:h}; return {sx:minX,sy:minY,sw:maxX-minX+1,sh:maxY-minY+1};
      }
    };

    /* ==== 背景（固定寸法） ==== */
    const BG = (()=> {
      const scaleY = H / IMG_BG.naturalHeight;
      const tileW  = IMG_BG.naturalWidth * scaleY;
      function draw(offsetX){
        let ox = offsetX % tileW; if (ox>0) ox -= tileW;
        for(let x=ox; x<W; x+=tileW){
          ctx.drawImage(IMG_BG, 0, 0, IMG_BG.naturalWidth, IMG_BG.naturalHeight,
                        Math.floor(x), 0, Math.ceil(tileW), H);
        }
      }
      return { draw };
    })();

    /* ==== 地面（固定寸法を共有） ==== */
    const GR = (()=> {
      const t=Px.topTrim(IMG_GR);
      const drawH=Math.max(48, Math.min(160, t.contentH));
      const srcY=t.trimTop, srcH=IMG_GR.naturalHeight - t.trimTop;
      const scaleY = drawH / srcH;
      const tileW  = IMG_GR.naturalWidth * scaleY;
      const y      = Math.floor(H - drawH);
      function floorY(){ return y; }
      function draw(offsetX){
        let ox = offsetX % tileW; if(ox>0) ox -= tileW;
        for(let x=ox;x<W;x+=tileW){
          ctx.drawImage(IMG_GR,0,srcY,IMG_GR.naturalWidth,srcH,
                        Math.floor(x), y, Math.ceil(tileW), drawH);
        }
      }
      return { draw, floorY, drawH };
    })();

    /* ==== プレイヤー ==== */
    function makePlayer(img){
      if(!img){ const c=document.createElement('canvas'); c.width=c.height=1; const g=c.getContext('2d'); g.fillStyle='#fff'; g.fillRect(0,0,1,1); img=c; }
      const b=Px.bottomTrim(img); const feetFrac=b.h? (b.bottomTrim/b.h):0;
      return { x:80, y:GR.floorY(), prevBottom:GR.floorY(), vy:0, w:48, h:48, jumps:2, img, feetFrac };
    }
    let player=null;

    /* ==== 障害物 ==== */
    const cornTrim  = Px.tightRect(IMG_CO);
    const contTrim  = Px.tightRect(IMG_CT);
    const trampTrim = Px.tightRect(IMG_TR);
    const gomiTrim  = Px.tightRect(IMG_GO);
    const obstacles=[]; // {x,y,w,h,img,trim,type,cd?,phase?,amp?,rotAmp?}

    function makeCorn(atX){
      const fy=GR.floorY();
      const targetH = Math.round(GR.drawH * 0.32); // 小さめ
      const s = targetH / cornTrim.sh;
      const w = Math.round(cornTrim.sw * s), h = Math.round(cornTrim.sh * s);
      return { x: atX, y: fy - h, w, h, img: IMG_CO, trim: cornTrim, type:'corn' };
    }
    function makeContSet(atX){
      const fy=GR.floorY();
      const targetH = Math.round(GR.drawH * 0.60); // 乗りやすい高さ
      const s = targetH / contTrim.sh;
      const w = Math.round(contTrim.sw * s), h = Math.round(contTrim.sh * s);
      const n = 2 + Math.floor(Math.random()*2); // 2 or 3
      const gap = 2;
      const arr=[];
      for(let i=0;i<n;i++){
        arr.push({ x: atX + i*(w+gap), y: fy - h, w, h, img: IMG_CT, trim: contTrim, type:'contena' });
      }
      return arr;
    }
    function makeTrampoline(atX){
      const fy=GR.floorY();
      const targetH = Math.round(GR.drawH * 0.40);
      const s = targetH / trampTrim.sh;
      const w = Math.round(trampTrim.sw * s), h = Math.round(trampTrim.sh * s);
      return { x: atX, y: fy - h, w, h, img: IMG_TR, trim: trampTrim, type:'tramp', cd:0 };
    }
    function makeGomi(atX){
      const fy=GR.floorY();
      const targetH = Math.round(GR.drawH * 0.34); // ≒コーン
      const s = targetH / gomiTrim.sh;
      const w = Math.round(gomiTrim.sw * s), h = Math.round(gomiTrim.sh * s);
      // 揺れパラメータ（見た目のみ）
      return {
        x: atX, y: fy - h, w, h, img: IMG_GO, trim: gomiTrim, type:'gomi',
        phase: Math.random()*Math.PI*2, amp: 3.0, rotAmp: 0.06 // amp(px), rotAmp(rad)
      };
    }

    /* ==== スポーン：重なり禁止 & 最低間隔 ==== */
    let nextAllowedDist = 200;
    const minGap = 90;
    const spawnMargin = 40;
    function rightmostFutureX(){
      let r = W + spawnMargin;
      for(const o of obstacles){ r = Math.max(r, o.x + o.w); }
      return r;
    }
    function trySpawn(totalDist){
      if(totalDist < nextAllowedDist) return;

      // corn : contena : tramp : gomi ＝ 40% : 30% : 15% : 15%
      const r = Math.random();
      let kind = r < 0.40 ? 'corn' : (r < 0.70 ? 'contena' : (r < 0.85 ? 'tramp' : 'gomi'));
      const startX = Math.max(W + spawnMargin, rightmostFutureX() + minGap);

      if(kind==='corn'){
        obstacles.push( makeCorn(startX) );
        nextAllowedDist = totalDist + 160 + Math.random()*160;

      }else if(kind==='contena'){
        const set = makeContSet(startX);
        obstacles.push(...set);
        const setWidth = (set[set.length-1].x + set[set.length-1].w) - set[0].x;
        nextAllowedDist = totalDist + Math.max(240, setWidth) + 160 + Math.random()*120;

      }else if(kind==='tramp'){
        obstacles.push( makeTrampoline(startX) );
        nextAllowedDist = totalDist + 220 + Math.random()*160;

      }else{ // gomi
        obstacles.push( makeGomi(startX) );
        nextAllowedDist = totalDist + 180 + Math.random()*160;
      }
    }

    /* ==== 進行・単発ブースト ==== */
    const GRAV=1500, JUMP=540, BASE=220, BOOST=700, BURST_DUR=0.9, CHARGE_RATE=28; // %/sec
    const KM=0.072;
    let speed=BASE, dist=0, bgOff=0, grOff=0;
    let boostCharge=100, burstActive=false, burstTimer=0;
    let gameOver=false;

    /* ==== HUD / 入力 ==== */
    const elDist=document.getElementById('dist'), elSpeed=document.getElementById('speed'),
          elJump=document.getElementById('jump'), elBoostPct=document.getElementById('boostPct');
    const btnJump=document.getElementById('btnJump'), btnBoost=document.getElementById('btnBoost');

    function updateHUD(){
      elDist.textContent=`距離 ${Math.floor(dist*0.02)} m`;
      elSpeed.textContent=`速度 ${Math.round(speed*KM)} km/h`;
      elJump.textContent=`ジャンプ ${player?player.jumps:2}`;
      elBoostPct.textContent=`${Math.round(boostCharge)}%`;
      if(boostCharge>=100 && !burstActive){ btnBoost.textContent='BOOST!'; btnBoost.classList.remove('muted'); }
      else{ btnBoost.textContent='充電中'; btnBoost.classList.add('muted'); }
    }

    btnJump.onpointerdown=e=>{ e.preventDefault(); if(player && !gameOver && player.jumps>0){ player.vy=-JUMP; player.jumps--; updateHUD(); } };
    btnBoost.onclick=e=>{
      e.preventDefault();
      if(gameOver) return;
      if(!burstActive && boostCharge>=100){ burstActive=true; burstTimer=BURST_DUR; boostCharge=0; updateHUD(); }
    };
    addEventListener('keydown',e=>{
      if(e.code==='Space'||e.code==='ArrowUp'){ if(player && !gameOver && player.jumps>0){ player.vy=-JUMP; player.jumps--; updateHUD(); } }
      if(e.code==='KeyB'){ if(!burstActive && boostCharge>=100 && !gameOver){ burstActive=true; burstTimer=BURST_DUR; boostCharge=0; updateHUD(); } }
    });
    document.getElementById('retryBtn').onclick=()=>{
      gameOver=false; dist=0; speed=BASE; bgOff=grOff=0; obstacles.length=0; nextAllowedDist=200;
      if(player){ player.y=GR.floorY(); player.prevBottom=player.y; player.vy=0; player.jumps=2; }
      boostCharge=100; burstActive=false; burstTimer=0;
      gameover.style.display='none';
    };

    /* ==== 判定ユーティリティ ==== */
    function hitConeRelax(px,py,pw,ph, cone){
      const baseH=cone.h, baseW=cone.w;
      const lower={ x:cone.x, y:cone.y + baseH*0.35, w:baseW,       h:baseH*0.65 };
      const upper={ x:cone.x + baseW*0.30, y:cone.y + baseH*0.05, w:baseW*0.40, h:baseH*0.30 };
      const A=(px<lower.x+lower.w&&px+pw>lower.x&&py<lower.y+lower.h&&py+ph>lower.y);
      const B=(px<upper.x+upper.w&&px+pw>upper.x&&py<upper.y+upper.h&&py+ph>upper.y);
      return A||B;
    }

    const LAND_SNAP = 10;      // 上面吸着（コンテナ/トランポリン）
    const H_PAD     = 16;      // 横方向バッファ
    const TRAMP_BOOST = 1.35;  // 反発力
    const TRAMP_CD    = 0.25;  // 連続発動防止

    /* ==== ループ ==== */
    let prev=0, running=false;
    function start(){ if(running) return; running=true; prev=performance.now(); updateHUD(); requestAnimationFrame(loop); }
    function loop(t){
      const dt = Math.min(0.033, (t-prev)/1000); prev=t;

      // ブースト（単発）
      if(!gameOver){
        if(burstActive){ speed=BOOST; burstTimer-=dt; if(burstTimer<=0){ burstActive=false; } }
        else { speed=BASE; boostCharge=Math.min(100, boostCharge + CHARGE_RATE*dt); }
      }

      // 物理
      if(player && !gameOver){
        player.prevBottom = player.y;
        player.vy += 1500*dt; // GRAV
        player.y  += player.vy*dt;
        const fy = GR.floorY();
        if(player.y > fy){ player.y = fy; player.vy = 0; player.jumps=2; }
      }

      // 進行
      if(!gameOver){
        dist  += speed*dt;
        bgOff -= speed*0.20*dt;
        grOff -= speed*1.00*dt;

        trySpawn(dist);
        for(let i=obstacles.length-1;i>=0;i--){
          const o=obstacles[i];
          o.x -= speed*dt;
          if(o.cd){ o.cd = Math.max(0, o.cd - dt); }
          if(o.phase!=null){ o.phase += dt*1.2; } // ゴミ箱の揺れ速度（rad/s）
          if(o.x + o.w < -40) obstacles.splice(i,1);
        }
      }

      // ===== 描画 =====
      ctx.clearRect(0,0,W,H);
      BG.draw(bgOff);
      GR.draw(grOff);

      obstacles.forEach(o=>{
        if(o.type==='gomi'){
          // 見た目だけ左右ゆらゆら＋ちょい回転（判定は元のAABBのまま）
          const dx = Math.sin(o.phase)*o.amp;
          const cx = Math.floor(o.x + o.w/2 + dx);
          const cy = Math.floor(o.y + o.h/2);
          ctx.save();
          ctx.translate(cx, cy);
          ctx.rotate(Math.sin(o.phase)*o.rotAmp);
          ctx.drawImage(o.img, o.trim.sx,o.trim.sy,o.trim.sw,o.trim.sh,
                        Math.floor(-o.w/2), Math.floor(-o.h/2), o.w, o.h);
          ctx.restore();
        }else{
          ctx.drawImage(o.img, o.trim.sx,o.trim.sy,o.trim.sw,o.trim.sh,
                        Math.floor(o.x), Math.floor(o.y), o.w, o.h);
        }
      });

      if(player){
        const feetPush = Math.floor(player.h * player.feetFrac);
        const px = Math.floor(player.x);
        const py = Math.floor(player.y - player.h + feetPush);
        ctx.drawImage(player.img, px, py, player.w, player.h);

        if(!gameOver){
          const currBottom = player.y;
          const prevBottom = player.prevBottom;

          for(const o of obstacles){
            // 判定はオブジェクトの基準位置（揺れ・回転は無視）で行う
            const overlapXWide = (px + player.w > o.x - H_PAD) && (px < o.x + o.w + H_PAD);
            const aabb = (px < o.x+o.w && px+player.w > o.x && py < o.y+o.h && py+player.h > o.y);
            if(!overlapXWide && !aabb) continue;

            if(o.type==='corn'){
              if(aabb && hitConeRelax(px,py,player.w,player.h,o)){ gameOver=true; gameover.style.display='grid'; break; }

            }else if(o.type==='contena'){
              const top = o.y, comingDown = player.vy >= 0;
              const crossed = (prevBottom <= top + LAND_SNAP) && (currBottom >= top - LAND_SNAP);
              if(comingDown && crossed && overlapXWide){
                player.y = top; player.vy = 0; player.jumps = 2;
              }else if(aabb){
                gameOver=true; gameover.style.display='grid'; break;
              }

            }else if(o.type==='tramp'){
              const top = o.y, comingDown = player.vy >= 0;
              const crossed = (prevBottom <= top + LAND_SNAP) && (currBottom >= top - LAND_SNAP);
              if(comingDown && crossed && overlapXWide && (!o.cd || o.cd<=0)){
                player.y = top;
                player.vy = -540 * TRAMP_BOOST; // JUMP * TRAMP_BOOST
                player.jumps = 2;
                o.cd = TRAMP_CD;
              }
              // 横からはスルー

            }else if(o.type==='gomi'){
              // コーン相当：触れたらゲームオーバー（AABB）
              if(aabb){ gameOver=true; gameover.style.display='grid'; break; }
            }
          }
        }
      }

      updateHUD();
      requestAnimationFrame(loop);
    }

    /* ==== キャラ選択 → スタート ==== */
    loading.style.display='none';
    overlay.style.display='grid';
    overlay.addEventListener('click', e=>{
      const c=e.target.closest('.choice'); if(!c) return;
      const img = (c.dataset.char==='VR' && IMG_VR) ? IMG_VR : (IMG_OR || IMG_VR);
      player = makePlayer(img);
      overlay.style.display='none';
      start();
    });

    /* ==== ページスクロール抑止（UI以外） ==== */
    ['touchstart','touchmove','gesturestart'].forEach(ev=>{
      document.addEventListener(ev, e=>{ if(e.target.closest('button,.choice'))return; e.preventDefault(); }, {passive:false});
    });

  }).catch(err=>{
    console.error(err);
    document.querySelector('#loading .bubble').textContent='画像の読み込みに失敗しました。ファイル名と配置を確認してください。';
  });
})();
</script>
</body>
</html>
