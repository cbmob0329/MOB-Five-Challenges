<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Runner Fix Floating</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden}
  #game{width:100%;height:100%;display:block;image-rendering:pixelated}
</style>
</head>
<body>
<canvas id="game" width="390" height="540"></canvas>
<script>
const cvs=document.getElementById("game"),ctx=cvs.getContext("2d");ctx.imageSmoothingEnabled=false;
const W=390,H=540;
function setup(){const dpr=devicePixelRatio||1;cvs.width=W*dpr;cvs.height=H*dpr;ctx.setTransform(dpr,0,0,dpr,0,0);}setup();

function load(src){return new Promise((res,rej)=>{const i=new Image();i.onload=()=>res(i);i.onerror=rej;i.src=src;});}
Promise.all([load("sora.png"),load("mob.png"),load("corn.png"),load("jumpdai.png"),load("VR.png")]).then(([imgBG,imgGR,imgCO,imgJP,imgPL])=>{

  // --- 透明トリム関数 ---
  function scanTopTrim(img){
    const w=img.naturalWidth,h=img.naturalHeight,oc=document.createElement("canvas");
    oc.width=w;oc.height=h;const ox=oc.getContext("2d",{willReadFrequently:true});ox.drawImage(img,0,0);
    const d=ox.getImageData(0,0,w,h).data,TH=12;let top=h;
    for(let y=0;y<h;y++){for(let x=0;x<w;x++){if(d[(y*w+x)*4+3]>TH){top=y;return{trimTop:top,contentH:h-top};}}}
    return{trimTop:0,contentH:h};
  }
  function scanBottomTrim(img){
    const w=img.naturalWidth,h=img.naturalHeight,oc=document.createElement("canvas");
    oc.width=w;oc.height=h;const ox=oc.getContext("2d",{willReadFrequently:true});ox.drawImage(img,0,0);
    const d=ox.getImageData(0,0,w,h).data,TH=12;
    for(let y=h-1;y>=0;y--){for(let x=0;x<w;x++){if(d[(y*w+x)*4+3]>TH){return{bottomTrim:h-1-y,h};}}}
    return{bottomTrim:0,h};
  }
  function scanTightRect(img){
    const w=img.naturalWidth,h=img.naturalHeight,oc=document.createElement("canvas");
    oc.width=w;oc.height=h;const ox=oc.getContext("2d",{willReadFrequently:true});ox.drawImage(img,0,0);
    const d=ox.getImageData(0,0,w,h).data,TH=12;
    let minX=w,minY=h,maxX=-1,maxY=-1;
    for(let y=0;y<h;y++){for(let x=0;x<w;x++){if(d[(y*w+x)*4+3]>TH){if(x<minX)minX=x;if(y<minY)minY=y;if(x>maxX)maxX=x;if(y>maxY)maxY=y;}}}
    if(maxX<0)return{sx:0,sy:0,sw:w,sh:h};
    return{sx:minX,sy:minY,sw:maxX-minX+1,sh:maxY-minY+1};
  }

  // --- 地面の床ライン決定 ---
  const {trimTop,contentH}=scanTopTrim(imgGR);
  const groundDrawH=contentH; 
  function floorY(){return H-groundDrawH;}

  // --- プレイヤー設定 ---
  const {bottomTrim,h:ph}=scanBottomTrim(imgPL);
  const playerFeetFrac=bottomTrim/ph;
  const player={x:80,y:floorY(),vy:0,w:48,h:48,jumps:2,img:imgPL,feetFrac:playerFeetFrac};

  // --- コーン/ジャンプ台準備 ---
  const cornTrim=scanTightRect(imgCO),jumpTrim=scanTightRect(imgJP);

  // --- ゲーム状態 ---
  let speed=220,dist=0,bgOff=0,grOff=0;
  const GRAV=1500,JUMP=540;
  const obstacles=[];let nextSpawn=200+Math.random()*300;

  function spawn(type){
    const fy=floorY();
    if(type==="corn"){
      const targetH=40,scale=targetH/cornTrim.sh,w=Math.round(cornTrim.sw*scale),h=Math.round(cornTrim.sh*scale);
      obstacles.push({x:W+40,y:fy-h,w,h,img:imgCO,trim:cornTrim,type:"corn"});
    }else{
      const targetH=20,scale=targetH/jumpTrim.sh,w=Math.round(jumpTrim.sw*scale),h=Math.round(jumpTrim.sh*scale);
      obstacles.push({x:W+40,y:fy-h,w,h,img:imgJP,trim:jumpTrim,type:"jump"});
    }
  }

  function drawTiled(img,y,hgt,off){
    const scale=hgt/img.naturalHeight,tileW=img.naturalWidth*scale;
    let ox=off%tileW;if(ox>0)ox-=tileW;
    for(let x=ox;x<W;x+=tileW){ctx.drawImage(img,0,trimTop,img.naturalWidth,img.naturalHeight-trimTop,Math.floor(x),y,tileW,hgt);}
  }

  let prev=0;
  function loop(t){
    const dt=(t-prev)/1000;prev=t;
    player.vy+=GRAV*dt;player.y+=player.vy*dt;
    const fy=floorY();if(player.y>fy){player.y=fy;player.vy=0;player.jumps=2;}
    dist+=speed*dt;bgOff-=speed*0.2*dt;grOff-=speed*1.0*dt;
    if(dist>nextSpawn){spawn(Math.random()<0.5?"corn":"jump");nextSpawn+=200+Math.random()*400;}
    for(let i=obstacles.length-1;i>=0;i--){obstacles[i].x-=speed*dt;if(obstacles[i].x+obstacles[i].w<-40)obstacles.splice(i,1);}
    ctx.clearRect(0,0,W,H);
    drawTiled(imgBG,0,H,bgOff);drawTiled(imgGR,floorY(),groundDrawH,grOff);
    obstacles.forEach(o=>ctx.drawImage(o.img,o.trim.sx,o.trim.sy,o.trim.sw,o.trim.sh,Math.floor(o.x),Math.floor(o.y),o.w,o.h));
    const px=player.x,py=player.y-player.h+player.h*player.feetFrac;
    ctx.drawImage(player.img,px,py,player.w,player.h);
    obstacles.forEach(o=>{
      if(px<o.x+o.w&&px+player.w>o.x&&py<o.y+o.h&&py+player.h>o.y){
        if(o.type==="jump"){player.vy=-JUMP*1.2;}
      }
    });
    requestAnimationFrame(loop);
  }
  loop();
});
</script>
</body>
</html>
