<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>ヴィラン掃除：移動と吹き出し修正</title>
<style>
  html,body{margin:0;height:100%;background:#0a0a0a;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Yu Gothic",sans-serif}
  #wrap{position:fixed;inset:0;display:flex;flex-direction:column}
  header{padding:8px 12px;font-size:14px;background:#121212;display:flex;gap:10px;align-items:center}
  header .dot{width:8px;height:8px;border-radius:50%;background:#18e06f;display:inline-block}
  canvas{flex:1;display:block;background:#111;touch-action:none}
  footer{padding:6px 10px;background:#121212;color:#aaa;font-size:12px}
</style>
</head>
<body>
<div id="wrap">
  <header>
    <span class="dot"></span><span>取りに行く時＝吹き出し同伴／戻り開始で吹き出し消去／端固着防止</span>
  </header>
  <canvas id="cv"></canvas>
  <footer>画面外へ取りに行き→戻る→フィールド内ホームへ復帰。端には固まらない仕様。</footer>
</div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const cx = cv.getContext('2d');

  // レイアウト
  function resize() {
    cv.width = Math.floor(window.innerWidth * (window.devicePixelRatio||1));
    cv.height = Math.floor(window.innerHeight * (window.devicePixelRatio||1) - 0);
    cv.style.width = '100%';
    cv.style.height = '100%';
  }
  addEventListener('resize', resize, {passive:true});
  resize();

  // フィールド安全域（端に固着しないための内側マージン）
  const MARGIN = 32; // 物理px（描画座標）
  const SPEED = 3;   // 基本速度
  const DT = 1;      // フレーム刻み

  // 吹き出し画像（任意）
  const bubbleImgs = {
    nera: loadImg('nera.png'),
    otosi: loadImg('otosi.png'),
    koti: loadImg('koti.png'),
    imada: loadImg('imada.png'),
    isoge: loadImg('isoge.png'),
    totte: loadImg('totte.png')
  };
  function loadImg(src){
    const img = new Image();
    img.src = src;
    return img;
  }

  // 文字吹き出しのフォールバック文言
  const bubbleTexts = {
    go: 'いってくる！',
    hurry: 'いそげ！',
    drop: 'おとすぞ…',
    think: 'ねらい中…',
  };

  // キャラクター
  const actor = {
    x: 0, y: 0, w: 40, h: 48,
    vx: 0, vy: 0,
    // “ホーム位置”＝戻り先（毎サイクル再抽選）
    homeX: 0, homeY: 0,
    state: 'idle', // idle | go_fetch | returning
    stateTimer: 0,
    speech: { visible:false, type:'', text:'', img:null },
  };

  function rand(min,max){ return Math.random()*(max-min)+min; }
  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  function playArea(){
    return {
      left: MARGIN,
      top: MARGIN,
      right: cv.width - MARGIN,
      bottom: cv.height - MARGIN
    };
  }

  function chooseHomeInside(){
    const A = playArea();
    actor.homeX = rand(A.left, A.right);
    actor.homeY = rand(A.top,  A.bottom);
  }

  // 初期配置
  chooseHomeInside();
  actor.x = actor.homeX;
  actor.y = actor.homeY;

  // 状態遷移ヘルパ
  function enterIdle(){
    actor.state = 'idle';
    actor.stateTimer = rand(60, 240); // 1〜4秒待機
    actor.vx = 0; actor.vy = 0;
    // 念のため端吸着からの復帰
    nudgeFromEdges();
  }
  function enterGoFetch(){
    actor.state = 'go_fetch';
    actor.stateTimer = 0;
    // 外へ出る方向（左か右の近い方へ）
    const towardsLeft = actor.x < cv.width/2;
    actor.vx = towardsLeft? -SPEED : SPEED;
    actor.vy = 0;
    // 吹き出しON（同伴）
    showBubblePick();
  }
  function enterReturning(){
    actor.state = 'returning';
    actor.stateTimer = 0;
    // 吹き出しOFF（戻りは非表示）
    hideBubble();
    // 速度はホームへ向ける
    aimToHome();
  }
  function aimToHome(){
    const dx = actor.homeX - actor.x;
    const dy = actor.homeY - actor.y;
    const len = Math.hypot(dx,dy) || 1;
    actor.vx = (dx/len) * SPEED;
    actor.vy = (dy/len) * SPEED;
  }

  // 吹き出し表示
  function showBubblePick(){
    // 画像があればランダムで選択、無ければテキスト
    const keys = Object.keys(bubbleImgs);
    const choice = keys[Math.floor(Math.random()*keys.length)];
    const img = bubbleImgs[choice];
    if (img && img.complete && img.naturalWidth>0){
      actor.speech.visible = true;
      actor.speech.img = img;
      actor.speech.text = '';
      actor.speech.type = 'img';
    } else {
      actor.speech.visible = true;
      actor.speech.img = null;
      actor.speech.type = 'text';
      // 文言もランダム
      const tkeys = Object.keys(bubbleTexts);
      actor.speech.text = bubbleTexts[tkeys[Math.floor(Math.random()*tkeys.length)]];
    }
  }
  function hideBubble(){
    actor.speech.visible = false;
    actor.speech.img = null;
    actor.speech.text = '';
    actor.speech.type = '';
  }

  // 端固着防止（内側へ軽く押し戻す & 微小ノイズ）
  function nudgeFromEdges(){
    const A = playArea();
    let nudged = false;
    if (actor.x < A.left){ actor.x = A.left + 1; nudged = true; }
    if (actor.x > A.right){ actor.x = A.right - 1; nudged = true; }
    if (actor.y < A.top){ actor.y = A.top + 1; nudged = true; }
    if (actor.y > A.bottom){ actor.y = A.bottom - 1; nudged = true; }
    if (nudged){
      // ゼロ速度で貼り付かないよう微小ランダム
      actor.vx += (Math.random()-0.5)*0.4;
      actor.vy += (Math.random()-0.5)*0.4;
    }
  }

  // 1サイクル： idle -> go_fetch -> returning -> idle
  enterIdle();

  // 取りに行く完了判定（画面外へ抜けたらOK）
  function isOffscreen(){
    const offMargin = 20;
    return (actor.x < -offMargin || actor.x > cv.width+offMargin ||
            actor.y < -offMargin || actor.y > cv.height+offMargin);
  }
  // ホーム到達判定
  function isAtHome(){
    const eps = 4;
    return Math.abs(actor.x - actor.homeX) < eps &&
           Math.abs(actor.y - actor.homeY) < eps;
  }

  // ループ
  function update(){
    // 状態更新
    if (actor.state === 'idle'){
      actor.stateTimer -= 1;
      // 指定時間待ったら取りに行く
      if (actor.stateTimer <= 0){
        // 次のホーム位置は戻り後に変える（戻ったら散らばるため）
        // 先に go_fetch へ
        enterGoFetch();
      } else {
        // 待機中に端固着にならないよう軽い内側バイアス
        nudgeFromEdges();
      }
    }
    else if (actor.state === 'go_fetch'){
      actor.x += actor.vx * DT;
      actor.y += actor.vy * DT;
      if (isOffscreen()){
        // 戻り開始：ここで次ホームを再抽選→必ず内側へ帰還
        chooseHomeInside();
        enterReturning();
      }
    }
    else if (actor.state === 'returning'){
      // 毎フレームホームへ向ける（数値誤差で停滞しないよう）
      aimToHome();
      actor.x += actor.vx * DT;
      actor.y += actor.vy * DT;
      if (isAtHome()){
        // 新しいホームに到着→次サイクルへ
        enterIdle();
      }
    }

    // 端からの吸着は常に避ける
    nudgeFromEdges();
  }

  // 描画
  function draw(){
    cx.clearRect(0,0,cv.width,cv.height);

    // フィールド安全域の可視化（デバッグ）
    cx.save();
    cx.strokeStyle = '#2a2a2a';
    cx.lineWidth = 2;
    cx.strokeRect(MARGIN, MARGIN, cv.width-2*MARGIN, cv.height-2*MARGIN);
    cx.restore();

    // “ホーム位置”目印
    cx.save();
    cx.fillStyle = '#0bd1ff';
    cx.globalAlpha = 0.15;
    cx.beginPath();
    cx.arc(actor.homeX, actor.homeY, 24, 0, Math.PI*2);
    cx.fill();
    cx.restore();

    // キャラクター（仮：丸）
    cx.save();
    cx.fillStyle = '#ffd83d';
    cx.beginPath();
    cx.ellipse(actor.x, actor.y, actor.w*0.5, actor.h*0.5, 0, 0, Math.PI*2);
    cx.fill();
    cx.restore();

    // 吹き出し（取りに行く時のみ可視）
    if (actor.speech.visible){
      const bx = actor.x + 18;   // 頭の横
      const by = actor.y - actor.h*0.7;
      if (actor.speech.img){
        const scale = 0.5; // 小さめ
        const iw = actor.speech.img.naturalWidth || 128;
        const ih = actor.speech.img.naturalHeight || 64;
        const dw = iw*scale, dh = ih*scale;
        cx.drawImage(actor.speech.img, bx, by, dw, dh);
      } else if (actor.speech.text){
        // シンプルテキスト吹き出し
        const pad = 8;
        cx.save();
        cx.font = 'bold 22px sans-serif';
        const w = cx.measureText(actor.speech.text).width + pad*2;
        const h = 30 + pad*2;
        cx.fillStyle = 'rgba(255,255,255,0.95)';
        roundRect(cx, bx, by, w, h, 8);
        cx.fill();
        cx.fillStyle = '#111';
        cx.fillText(actor.speech.text, bx+pad, by+pad+22);
        // しっぽ
        cx.beginPath();
        cx.moveTo(bx+10, by+h);
        cx.lineTo(bx+22, by+h);
        cx.lineTo(bx+14, by+h+10);
        cx.closePath();
        cx.fill();
        cx.restore();
      }
    }
  }

  function roundRect(ctx,x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // ループ駆動
  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }
  loop();

})();
</script>
</body>
</html>
