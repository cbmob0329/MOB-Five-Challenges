<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no" />
<title>Runner – stable ground & UI</title>
<meta name="theme-color" content="#0b0c10" />
<style>
  :root{ --stage-w:390px; --stage-h:700px; }
  html,body{height:100%;margin:0;background:#000;color:#fff;overscroll-behavior:none}
  #root{position:fixed;inset:0;display:grid;place-items:center}
  #phone{
    width:var(--stage-w);height:var(--stage-h);position:relative;overflow:hidden;
    background:#070b12;border-radius:16px;border:1px solid #0e1522;box-shadow:0 12px 40px rgba(0,0,0,.45);
    transform-origin:center center;
  }

  /* HUD / ボタン（Canvasの外側に固定） */
  header.hud{
    position:absolute;left:0;right:0;top:env(safe-area-inset-top);height:56px;z-index:20;
    display:flex;gap:10px;align-items:center;justify-content:space-around;padding:8px 10px;
    background:linear-gradient(180deg,rgba(12,18,28,.9),rgba(10,14,22,.8)); border-bottom:1px solid rgba(255,255,255,.06);
    font:600 12px/1 system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif;
  }
  main.play{position:absolute;left:0;right:0;top:56px;bottom:88px}
  canvas#game{width:100%;height:100%;display:block;image-rendering:pixelated;background:transparent}
  footer.ctrl{
    position:absolute;left:0;right:0;bottom:env(safe-area-inset-bottom);height:88px;z-index:20;
    display:flex;gap:14px;align-items:center;justify-content:center;padding:10px;
    background:linear-gradient(180deg,rgba(10,14,22,.8),rgba(7,10,16,.95)); border-top:1px solid rgba(255,255,255,.06);
  }
  .btn{
    -webkit-tap-highlight-color:transparent; user-select:none; touch-action:manipulation;
    min-width:120px;padding:12px 16px;border-radius:14px;border:1px solid rgba(255,255,255,.1);
    background:#182233;font-weight:800;color:#fff;box-shadow:0 6px 20px rgba(0,0,0,.35);font-size:16px;
  }
  .btn:active{transform:translateY(1px)}

  /* キャラ選択オーバーレイ */
  #overlay{
    position:absolute;inset:56px 0 88px;display:none;place-items:center;z-index:30;
    background:linear-gradient(180deg,rgba(0,0,0,.35),rgba(0,0,0,.35));
  }
  .card{width:min(92%,360px);background:#0c121f;border:1px solid rgba(255,255,255,.1);border-radius:16px;padding:16px}
  .choices{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .choice{display:grid;gap:8px;justify-items:center;background:#111a2a;border:1px solid rgba(255,255,255,.08);border-radius:12px;padding:10px;cursor:pointer}
  .choice img{width:72px;height:72px;object-fit:contain;background:#0b0f18;border-radius:10px;border:1px solid rgba(255,255,255,.06)}
  #loading{position:absolute;inset:56px 0 88px;display:grid;place-items:center;z-index:40;background:rgba(0,0,0,.6)}
  .bubble{padding:10px 14px;border-radius:12px;background:#111a2a;border:1px solid rgba(255,255,255,.08);font-size:13px}
</style>
</head>
<body>
<div id="root">
  <div id="phone">
    <header class="hud">
      <div id="dist">距離 0 m</div>
      <div id="speed">速度 0 km/h</div>
      <div id="jump">ジャンプ 2</div>
      <div id="coin">コイン 0</div>
    </header>

    <main class="play"><canvas id="game" width="390" height="540"></canvas></main>

    <footer class="ctrl">
      <button class="btn" id="btnJump">ジャンプ</button>
      <button class="btn" id="btnBoost">ブースト</button>
    </footer>

    <div id="overlay">
      <div class="card">
        <p style="margin:0 0 8px;font-weight:800;">どちらか選択してスタート</p>
        <p style="margin:0 0 12px;color:#9aa3b2;">リポジトリ直下に画像を置いてください。</p>
        <div class="choices">
          <div class="choice" data-char="VR"><img src="VR.png" alt="VR"><small>VR.png</small></div>
          <div class="choice" data-char="orange"><img src="orange.png" alt="orange"><small>orange.png</small></div>
        </div>
      </div>
    </div>

    <div id="loading"><div class="bubble">画像読み込み中…</div></div>
  </div>
</div>

<script>
(() => {
  /* ===== PCでもスマホと同じ画角でプレビュー ===== */
  const phone = document.getElementById('phone');
  function fit(){ const s=Math.min(innerWidth/390, innerHeight/700); phone.style.transform=`scale(${s})`; }
  addEventListener('resize', fit, {passive:true}); fit();

  /* ===== Canvas 基本 ===== */
  const cvs=document.getElementById('game'), ctx=cvs.getContext('2d',{alpha:true});
  ctx.imageSmoothingEnabled=false;
  const W=390, H=540;
  function setup(){ const dpr=Math.max(1,devicePixelRatio||1); cvs.width=W*dpr; cvs.height=H*dpr; ctx.setTransform(dpr,0,0,dpr,0,0); }
  setup(); addEventListener('resize', setup, {passive:true});

  /* ===== 画像プリロード（完了してからUIを見せる） ===== */
  function load(src){ return new Promise((res,rej)=>{ const i=new Image(); i.onload=()=>res(i); i.onerror=rej; i.src=src; }); }
  const overlay = document.getElementById('overlay');
  const loading = document.getElementById('loading');

  Promise.all([
    load('sora.png'),    // 背景
    load('mob.png'),     // 地面
    load('corn.png'),    // コーン
    load('jumpdai.png'), // ジャンプ台
    load('VR.png').catch(()=>null),
    load('orange.png').catch(()=>null),
  ]).then(([imgBG,imgGR,imgCO,imgJP,imgVR,imgOR])=>{

    /* ==== ピクセルスキャン ==== */
    function scanTopTrim(img){
      const w=img.naturalWidth,h=img.naturalHeight,oc=document.createElement('canvas'); oc.width=w; oc.height=h;
      const ox=oc.getContext('2d',{willReadFrequently:true}); ox.drawImage(img,0,0);
      const d=ox.getImageData(0,0,w,h).data, TH=12;
      for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ if(d[(y*w+x)*4+3]>TH) return {trimTop:y, contentH:h-y}; } }
      return {trimTop:0, contentH:h};
    }
    function scanBottomTrim(img){
      const w=img.naturalWidth,h=img.naturalHeight,oc=document.createElement('canvas'); oc.width=w; oc.height=h;
      const ox=oc.getContext('2d',{willReadFrequently:true}); ox.drawImage(img,0,0);
      const d=ox.getImageData(0,0,w,h).data, TH=12;
      for(let y=h-1;y>=0;y--){ for(let x=0;x<w;x++){ if(d[(y*w+x)*4+3]>TH) return {bottomTrim:h-1-y, h}; } }
      return {bottomTrim:0, h};
    }
    function scanTightRect(img){
      const w=img.naturalWidth,h=img.naturalHeight,oc=document.createElement('canvas'); oc.width=w; oc.height=h;
      const ox=oc.getContext('2d',{willReadFrequently:true}); ox.drawImage(img,0,0);
      const d=ox.getImageData(0,0,w,h).data, TH=12;
      let minX=w,minY=h,maxX=-1,maxY=-1;
      for(let y=0;y<h;y++){ for(let x=0;x<w;x++){ if(d[(y*w+x)*4+3]>TH){ if(x<minX)minX=x; if(y<minY)minY=y; if(x>maxX)maxX=x; if(y>maxY)maxY=y; } } }
      if(maxX<0) return {sx:0,sy:0,sw:w,sh:h};
      return {sx:minX, sy:minY, sw:maxX-minX+1, sh:maxY-minY+1};
    }

    /* ==== 地面の床ライン（mob.png 上端をトリム） ==== */
    const {trimTop: groundTrimTop, contentH: groundContentH} = scanTopTrim(imgGR);
    const groundDrawH = Math.max(48, Math.min(160, groundContentH)); // 画面上の見た目厚み
    const floorY = () => Math.floor(H - groundDrawH);                 // 接地ライン

    /* ==== 画像トリム情報 ==== */
    const cornTrim = scanTightRect(imgCO);
    const jumpTrim = scanTightRect(imgJP);

    /* ==== 背景と地面を分離描画 ==== */
    function drawBG(offsetX){
      const scaleY = H / imgBG.naturalHeight;
      const tileW  = imgBG.naturalWidth * scaleY;
      let ox = offsetX % tileW; if (ox>0) ox -= tileW;
      for(let x=ox; x<W; x+=tileW){
        ctx.drawImage(imgBG, 0, 0, imgBG.naturalWidth, imgBG.naturalHeight,
                      Math.floor(x), 0, Math.ceil(tileW), H);
      }
    }
    function drawGround(offsetX){
      const srcY = groundTrimTop;
      const srcH = imgGR.naturalHeight - groundTrimTop;
      const scaleY = groundDrawH / srcH;
      const tileW  = imgGR.naturalWidth * scaleY;
      let ox = offsetX % tileW; if (ox>0) ox -= tileW;
      const y = floorY();
      for(let x=ox; x<W; x+=tileW){
        ctx.drawImage(imgGR, 0, srcY, imgGR.naturalWidth, srcH,
                      Math.floor(x), y, Math.ceil(tileW), groundDrawH);
      }
    }

    /* ==== プレイヤー ==== */
    function makePlayer(img){
      const {bottomTrim, h} = scanBottomTrim(img);
      const feetFrac = bottomTrim / h; // 下端透明ぶん
      return { x:80, y:floorY(), vy:0, w:48, h:48, jumps:2, img, feetFrac };
    }
    let player = null;

    /* ==== 障害物（接地・縦横比維持） ==== */
    const obstacles = []; // {x,y,w,h,img,trim,type}
    function spawn(){
      const fy = floorY();
      if (Math.random()<0.5){
        // コーン：地面高さの 70%
        const targetH = Math.round(groundDrawH * 0.70);
        const scale   = targetH / cornTrim.sh;
        const w = Math.round(cornTrim.sw * scale), h = Math.round(cornTrim.sh * scale);
        obstacles.push({ x:W+40, y:fy - h, w, h, img:imgCO, trim:cornTrim, type:'corn' });
      }else{
        // ジャンプ台：地面高さの 50%
        const targetH = Math.round(groundDrawH * 0.50);
        const scale   = targetH / jumpTrim.sh;
        const w = Math.round(jumpTrim.sw * scale), h = Math.round(jumpTrim.sh * scale);
        obstacles.push({ x:W+40, y:fy - h, w, h, img:imgJP, trim:jumpTrim, type:'jump' });
      }
    }

    /* ==== 状態/HUD/入力 ==== */
    const GRAV=1500, JUMP=540, BASE=220, BOOST=480, KM=0.072;
    let speed=BASE, boosting=false, boost=60, dist=0, bgOff=0, grOff=0;
    const elDist=document.getElementById('dist'), elSpeed=document.getElementById('speed'),
          elJump=document.getElementById('jump'), elCoin=document.getElementById('coin');
    function updateHUD(){
      elDist.textContent = `距離 ${Math.floor(dist*0.02)} m`;
      elSpeed.textContent= `速度 ${Math.round(speed*KM)} km/h`;
      elJump.textContent = `ジャンプ ${player?player.jumps:2}`;
      elCoin.textContent = `コイン 0`;
    }
    const btnJump=document.getElementById('btnJump'), btnBoost=document.getElementById('btnBoost');
    btnJump.onpointerdown = e=>{ e.preventDefault(); if(player && player.jumps>0){ player.vy=-JUMP; player.jumps--; updateHUD(); } };
    btnBoost.onpointerdown= e=>{ e.preventDefault(); boosting=true;  };
    btnBoost.onpointerup  = e=>{ e.preventDefault(); boosting=false; };

    addEventListener('keydown', e=>{ if(e.code==='Space'||e.code==='ArrowUp'){ if(player && player.jumps>0){ player.vy=-JUMP; player.jumps--; updateHUD(); } } if(e.code==='ShiftLeft'||e.code==='KeyB'){ boosting=true; } });
    addEventListener('keyup',   e=>{ if(e.code==='ShiftLeft'||e.code==='KeyB'){ boosting=false; } });

    /* ==== メインループ ==== */
    let prev=0, running=false; 
    function start(){ if(running) return; running=true; prev=performance.now(); updateHUD(); requestAnimationFrame(loop); }
    function loop(t){
      const dt = Math.min(0.033, (t-prev)/1000); prev=t;

      // スピード
      if(boosting && boost>0){ speed=BOOST; boost=Math.max(0, boost-24*dt); }
      else { speed=BASE; boost=Math.min(100, boost+10*dt); }

      // 物理（床ラインでビタ止め）
      if(player){
        player.vy += GRAV*dt;
        player.y  += player.vy*dt;
        const fy = floorY();
        if(player.y > fy){ player.y=fy; player.vy=0; player.jumps=2; }
      }

      // 進行・スポーン
      dist  += speed*dt;
      bgOff -= speed*0.20*dt;
      grOff -= speed*1.00*dt;
      if(obstacles.length===0 || obstacles[obstacles.length-1].x < W-180) spawn();
      for(let i=obstacles.length-1;i>=0;i--){
        obstacles[i].x -= speed*dt;
        if(obstacles[i].x + obstacles[i].w < -40) obstacles.splice(i,1);
      }

      // 描画（背景→地面→障害物→プレイヤー）
      ctx.clearRect(0,0,W,H);
      drawBG(bgOff);
      drawGround(grOff);
      obstacles.forEach(o=>{
        ctx.drawImage(o.img, o.trim.sx, o.trim.sy, o.trim.sw, o.trim.sh,
                      Math.floor(o.x), Math.floor(o.y), o.w, o.h);
      });
      if(player){
        const feetPush = Math.floor(player.h * player.feetFrac);
        const px = Math.floor(player.x);
        const py = Math.floor(player.y - player.h + feetPush); // ←足元補正で接地
        ctx.drawImage(player.img, px, py, player.w, player.h);
        // ジャンプ台に乗ったら強制ジャンプ
        for(const o of obstacles){
          if (px < o.x+o.w && px+player.w > o.x && py < o.y+o.h && py+player.h > o.y){
            if (o.type==='jump'){ player.vy = -JUMP*1.2; }
          }
        }
      }

      updateHUD();
      requestAnimationFrame(loop);
    }

    /* ==== キャラ選択 → スタート ==== */
    loading.style.display='none';
    overlay.style.display='grid';
    overlay.addEventListener('click', e=>{
      const c=e.target.closest('.choice'); if(!c) return;
      const img = (c.dataset.char==='VR' && imgVR) ? imgVR : (imgOR || imgVR);
      player = makePlayer(img);
      overlay.style.display='none';
      start();
    });

    /* ==== ページスクロール抑止（UI以外） ==== */
    ['touchstart','touchmove','gesturestart'].forEach(ev=>{
      document.addEventListener(ev, e=>{ if(e.target.closest('button,.choice'))return; e.preventDefault(); }, {passive:false});
    });

  }).catch(err=>{
    console.error(err);
    document.querySelector('#loading .bubble').textContent = '画像読み込み失敗：ファイル名と配置を確認してください。';
  });
})();
</script>
</body>
</html>
