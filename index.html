<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, user-scalable=no, maximum-scale=1">
<title>MOB CART Runner</title>
<style>
  :root{ --fg:#fff; --pill:#2b2f3a; --btn:#1b1f27; --btn2:#2b303b; }
  html,body{ margin:0; height:100%; background:#000; color:#fff;
    font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Sans','Yu Gothic',sans-serif; }
  #wrap{ position:fixed; inset:0; display:flex; align-items:center; justify-content:center; background:#000; }
  #stage{ position:relative; width:100vw; height:100vh; }
  #cv{ position:relative; z-index:0; display:block; width:100%; height:100%; background:#000; touch-action:none; }

  .hud{ position:absolute; inset:0; pointer-events:none; z-index:10; }
  .top{ position:absolute; left:10px; right:10px; top:calc(8px + env(safe-area-inset-top)); display:flex; gap:10px; align-items:center}
  .pill{ background:var(--pill); border-radius:999px; padding:6px 12px; font-weight:700; font-size:14px; box-shadow:0 4px 12px rgba(0,0,0,.25) }
  .grow{ flex:1; display:flex; align-items:center; gap:8px }
  .mini{ font-size:12px; opacity:.8 }
  .boostRow{ position:absolute; left:10px; right:10px; top:calc(46px + env(safe-area-inset-top)); pointer-events:none }
  .boostBar{ height:18px; background:#262f3c; border:1px solid #3f4a5d; border-radius:12px; overflow:hidden; box-shadow:0 6px 18px rgba(0,0,0,.35) }
  .boostBar i{ display:block; height:100%; width:0%; background:linear-gradient(90deg,#29d,#6ef); transition:width .08s linear }
  .boostReady{ box-shadow:0 0 16px rgba(90,240,255,.65), inset 0 0 10px rgba(120,220,255,.45) }

  .bottom{ position:absolute; left:10px; right:10px; bottom:calc(14px + env(safe-area-inset-bottom));
           display:grid; grid-template-columns:1fr 64px 64px 1fr; gap:10px; pointer-events:none }
  .bbtn{ pointer-events:auto; background:var(--btn2); border:1px solid #333c4c; border-radius:16px;
         padding:14px 12px; font-weight:900; text-align:center; box-shadow:0 10px 22px rgba(0,0,0,.35) }
  .bbtn:active{ transform:translateY(1px) }
  .slot{ pointer-events:auto; height:56px; border-radius:12px; border:1px dashed #666; background:rgba(255,255,255,.06); display:grid; place-items:center }
  .slot img{ max-width:90%; max-height:90%; image-rendering:pixelated }
  .slot.empty{ opacity:.35 }
  .hidden{ display:none !important }

  .center{ position:absolute; inset:0; display:grid; place-items:center; pointer-events:none }
  .panel{ pointer-events:auto; width:min(94%,560px); background:rgba(15,18,26,.92); border:1px solid #2a3242;
          border-radius:18px; padding:18px; box-shadow:0 20px 60px rgba(0,0,0,.6) }
  .panel h1,.panel h2{ margin:8px 0 14px }
  .row{ display:flex; gap:10px; flex-wrap:wrap }
  .btn{ pointer-events:auto; background:var(--btn); border:1px solid #323a49; border-radius:14px; padding:12px 16px; font-weight:800 }
  .btn:active{ transform:translateY(1px) }
  .ok{ background:#133; border-color:#1f6 }
  .danger{ background:#2a1516; border-color:#a33 }
  .charWrap{ display:flex; gap:10px }
  .card{ flex:1 1 48%; background:rgba(255,255,255,.04); border:1px solid #2c3444; border-radius:14px; padding:10px;
         display:grid; place-items:center }
  .card img{ width:110px; height:auto; image-rendering:pixelated }
  .sel{ outline:3px solid #2bd36b }

  .count{ position:absolute; inset:0; display:grid; place-items:center; font-size:60px; font-weight:900; text-shadow:0 4px 16px #000; pointer-events:none }

  .cutin{ position:absolute; left:50%; top:35%; transform:translate(-50%,-50%); pointer-events:none }
  .cutin img{ width:min(50vw, 420px); height:auto; display:block; opacity:0; animation:cut 2s ease forwards; image-rendering:pixelated }
  @keyframes cut{
    0%{opacity:0; transform:translate(-50%,-44%) scale(.98)}
    15%{opacity:1; transform:translate(-50%,-50%) scale(1)}
    85%{opacity:1}
    100%{opacity:0; transform:translate(-50%,-56%) scale(1.02)}
  }

  .toast{ position:absolute; inset:0; display:grid; place-items:center; font-size:26px; font-weight:900; text-align:center; white-space:pre-line; text-shadow:0 2px 8px #000; animation:fade 1.8s ease forwards; pointer-events:none }
  @keyframes fade{ 0%{opacity:0} 20%{opacity:1} 80%{opacity:1} 100%{opacity:0} }

  .result{ position:absolute; left:50%; top:40%; transform:translate(-50%,-50%); background:rgba(0,0,0,.65); border:1px solid #444;
           border-radius:14px; padding:10px 14px; font-weight:900; opacity:0; animation:res 2s ease forwards; white-space:pre-line; text-align:center; pointer-events:none }
  @keyframes res{ 0%{opacity:0; transform:translate(-50%,-46%)} 20%{opacity:1; transform:translate(-50%,-50%)} 80%{opacity:1} 100%{opacity:0; transform:translate(-50%,-54%)} }
</style>
</head>
<body>
<div id="wrap">
  <div id="stage">
    <canvas id="cv"></canvas>

    <div class="hud">
      <div class="top">
        <div class="pill" id="distPill">距離 0 m</div>
        <div class="pill" id="spdPill">速度 0 km/h</div>
        <div class="pill" id="jumpPill">ジャンプ ×2</div>
        <div class="pill mini" id="coinPill">コイン 0/10</div>
      </div>
      <div class="boostRow"><div class="boostBar" id="boostBar"><i id="boostFill"></i></div></div>

      <div class="bottom">
        <div class="bbtn" id="btnJump">ジャンプ</div>
        <div class="slot empty" id="slot1"></div>
        <div class="slot empty" id="slot2"></div>
        <div class="bbtn" id="btnBoost">ブースト</div>
      </div>

      <div class="center">
        <div class="panel" id="panelOP">
          <h1>ゲームを開始しますか？</h1>
          <div class="row">
            <div class="btn ok" id="opYes">はい</div>
            <div class="btn danger" id="opNo">いいえ</div>
          </div>
        </div>

        <div class="panel hidden" id="panelChar">
          <h2>キャラクター選択</h2>
          <div class="charWrap">
            <div class="card sel" data-char="orange">
              <img src="orange.png" alt="MOBオレンジ"><div>MOBオレンジ</div>
            </div>
            <div class="card" data-char="VR">
              <img src="VR.png" alt="MOBVR"><div>MOBVR</div>
            </div>
          </div>
          <div class="row" style="margin-top:10px">
            <div class="btn ok" id="charStart">スタート</div>
            <div class="btn" id="charBack">戻る</div>
          </div>
        </div>

        <div class="panel hidden" id="panelMenu">
          <h2>どうする？</h2>
          <div class="row">
            <div class="btn" id="menuChar">キャラ選択</div>
            <div class="btn ok" id="menuStart">スタート</div>
            <div class="btn danger" id="menuQuit">やめる</div>
          </div>
        </div>

        <div class="panel hidden" id="panelQuit">
          <h2>アプリを終了しました</h2>
          <div style="color:#bbb">このタブを閉じてください。</div>
        </div>
      </div>

      <div class="count hidden" id="count">3</div>
      <div class="cutin hidden" id="cutin"><img id="cutinImg" src="" alt=""></div>
      <div class="toast hidden" id="toast"></div>
      <div class="result hidden" id="resultMsg"></div>
    </div>
  </div>
</div>

<script>
(() => {
  /* ===== 基本セットアップ ===== */
  const cv = document.getElementById('cv');
  const cx = cv.getContext('2d', { alpha:false });
  let W=0, H=0, DPR=1;
  function fit(){
    const vw = window.innerWidth;
    const vh = (window.visualViewport ? window.visualViewport.height : window.innerHeight);
    DPR = Math.min(2, window.devicePixelRatio || 1);
    W = Math.max(1, Math.floor(vw));
    H = Math.max(1, Math.floor(vh));
    cv.style.width = W + 'px';
    cv.style.height = H + 'px';
    cv.width  = Math.round(W * DPR);
    cv.height = Math.round(H * DPR);
    cx.setTransform(DPR,0,0,DPR,0,0);
  }
  addEventListener('resize', fit, {passive:true});
  if (window.visualViewport) window.visualViewport.addEventListener('resize', fit, {passive:true});
  fit();

  const files = {
    road:'do-ro.png', field:'hatake2.png',
    sora:'sora.PNG', corn:'corn.PNG',
    op:'op.png', orange:'orange.png', VR:'VR.png',
    dokan:'dokan.png', jumpdai:'jumpdai.png',
    kanban1:'kanban1.png', kanban2:'kanban2.png', kanban3:'kanban3.png',
    kanban4:'kanban4.png', kanban5:'kanban5.png', kanban6:'kanban6.png',
    coin:'coin.png', gold:'gold.png', hoshi1:'hoshi1.png', hoshi2:'hoshi2.png', mutekiop:'mutekiop.png',
    viranop:'viran op.png', viran:'viran.png', tama:'tama.png',
    tsubasa:'tsubasa.png', jump:'jump.png', en:'en.png'
  };
  const IM={};
  const ready = Promise.all(Object.entries(files).map(([k,src])=>new Promise(ok=>{
    const i=new Image();
    i.onload=()=>{IM[k]=i;ok();};
    i.onerror=()=>{const c=document.createElement('canvas');c.width=64;c.height=64;const x=c.getContext('2d');
      x.fillStyle='#444';x.fillRect(0,0,64,64);x.fillStyle='#fff';x.font='10px sans-serif';x.fillText(k,4,14);IM[k]=c;ok();};
    i.src=src;
  })));

  const distPill=document.getElementById('distPill');
  const spdPill =document.getElementById('spdPill');
  const jumpPill=document.getElementById('jumpPill');
  const coinPill=document.getElementById('coinPill');
  const boostFill=document.getElementById('boostFill');
  const boostBar =document.getElementById('boostBar');
  const panelOP  =document.getElementById('panelOP');
  const panelChar=document.getElementById('panelChar');
  const panelMenu=document.getElementById('panelMenu');
  const panelQuit=document.getElementById('panelQuit');
  const countEl  =document.getElementById('count');
  const cutinBox =document.getElementById('cutin');
  const cutinImg =document.getElementById('cutinImg');
  const toast    =document.getElementById('toast');
  const resultMsg=document.getElementById('resultMsg');
  const slotEls  =[document.getElementById('slot1'),document.getElementById('slot2')];
  const btnJump  =document.getElementById('btnJump');
  const btnBoost =document.getElementById('btnBoost');

  function show(el){el.classList.remove('hidden');}
  function hide(el){el.classList.add('hidden');}
  function t(){return performance.now();}
  function rnd(a,b){return Math.floor(a+Math.random()*(b-a+1));}
  function seamY(){ return Math.floor(H*0.64); } // 畑下端＝道路上端＝接地ライン
  const GROUND_VISUAL_OFFSET = 6;               // ← 浮き見え対策（描画のみ下げる）

  /* ===== ステート ===== */
  const ST={TITLE:0,CHARSEL:1,COUNT:2,RUN:3,OVER:4,MENU:5,QUIT:6};
  let state=ST.TITLE;

  document.getElementById('opYes').onclick=()=>{ if(state!==ST.TITLE) return; state=ST.CHARSEL; show(panelChar); hide(panelOP); };
  document.getElementById('opNo').onclick=()=>{ hide(panelOP); show(panelQuit); state=ST.QUIT; };

  let selected='orange';
  panelChar.addEventListener('click',e=>{
    const card=e.target.closest('.card'); if(!card) return;
    selected=card.dataset.char;
    panelChar.querySelectorAll('.card').forEach(el=>el.classList.toggle('sel', el.dataset.char===selected));
  });
  document.getElementById('charBack').onclick=()=>{hide(panelChar);show(panelOP);state=ST.TITLE;};
  document.getElementById('charStart').onclick=()=>{startCountdown(selected);};
  document.getElementById('menuChar').onclick=()=>{show(panelChar);hide(panelMenu);state=ST.CHARSEL;};
  document.getElementById('menuStart').onclick=()=>{hide(panelMenu);startCountdown(selected);};
  document.getElementById('menuQuit').onclick=()=>{hide(panelMenu);show(panelQuit);state=ST.QUIT;};

  /* ===== 世界とプレイヤー ===== */
  const world={
    scrollX:0, baseSpeed:3.8, speed:3.8, maxSpeed:8.5,
    gravity:0.72, meters:0, coins:0,
    boostGauge:0, boostFillMs:10000, boostReady:false, boosting:false, boostUntil:0,
    signs:[], obstacles:[], items:[], fires:[], hazards:[],
    nextObsX:0, nextItemX:0, nextSignAtX:1500, nextViranAt:rnd(500,900),
    safeUntilMeters:180
  };
  const player={ x:0, y:0, w:48, h:54, vy:0, onGround:false, jumps:2, maxJumps:2, wingsUntil:0, sprite:'orange', gold:false,
                 xPrev:0, yPrev:0 };

  function resetRun(){
    world.scrollX=0; world.speed=world.baseSpeed; world.meters=0; world.coins=0;
    world.boostGauge=0; world.boostReady=false; world.boosting=false; player.gold=false;
    world.signs.length=0; world.obstacles.length=0; world.items.length=0; world.fires.length=0; world.hazards.length=0;
    world.nextObsX = Math.floor(W + 420);
    world.nextItemX= Math.floor(W + 1600);
    world.nextSignAtX = Math.floor(W + 2400);
    world.nextViranAt=rnd(500,900);
    player.x=Math.floor(W*0.22); player.y=seamY()-player.h; player.vy=0; player.onGround=true; player.jumps=0; player.maxJumps=2; player.wingsUntil=0;
    slots[0]=null; slots[1]=null; refreshSlots(); refreshHUD();
  }

  function startCountdown(sel){
    hide(panelOP);hide(panelChar);hide(panelMenu);hide(panelQuit); hide(resultMsg);resultMsg.textContent='';
    player.sprite=sel||'orange';
    resetRun();
    let n=3;countEl.textContent=n;show(countEl);state=ST.COUNT;
    const timer=setInterval(()=>{
      n--;
      if(n>0){countEl.textContent=n;}
      else if(n===0){countEl.textContent='GO';}
      else{clearInterval(timer);hide(countEl);state=ST.RUN;}
    },700);
  }

  /* ===== 入力・アイテム ===== */
  const slotEls=[document.getElementById('slot1'),document.getElementById('slot2')];
  const btnJump=document.getElementById('btnJump');
  const btnBoost=document.getElementById('btnBoost');
  btnJump.addEventListener('touchstart',e=>{e.preventDefault();doJump();},{passive:false});
  btnJump.addEventListener('mousedown',e=>{e.preventDefault();doJump();});
  btnBoost.addEventListener('touchstart',e=>{e.preventDefault();tryBoost();},{passive:false});
  btnBoost.addEventListener('mousedown',e=>{e.preventDefault();tryBoost();});
  addEventListener('keydown',e=>{
    if(e.code==='Space'||e.code==='ArrowUp'){e.preventDefault();doJump();}
    if(e.code==='ShiftLeft'||e.code==='ShiftRight'){e.preventDefault();tryBoost();}
    if(e.code==='Digit1'){useItem(0);} if(e.code==='Digit2'){useItem(1);}
  });

  const slots=[null,null];
  slotEls[0].addEventListener('click',()=>useItem(0));
  slotEls[1].addEventListener('click',()=>useItem(1));
  slotEls.forEach((el,i)=>el.addEventListener('touchstart',e=>{e.preventDefault();useItem(i);},{passive:false}));

  function doJump(){
    if(state!==ST.RUN) return;
    if(player.onGround || player.jumps<player.maxJumps){
      player.vy=-14; player.onGround=false; player.jumps++;
      jumpPill.textContent=`ジャンプ ×${player.maxJumps}`;
    }
  }
  function tryBoost(){
    if(state!==ST.RUN) return;
    const free=t()<(world.boostFreeUntil||0);
    if(world.boosting && t()<world.boostUntil) return;
    if(world.boostReady || free){
      world.boosting=true; world.boostUntil=t()+2500;
      world.speed=Math.min(world.maxSpeed, world.baseSpeed*1.8);
      if(world.boostReady){ world.boostReady=false; world.boostGauge=0; }
    }
  }
  function addItem(type){
    if(slots[0] && slots[1]){ showToast('アイテム枠がいっぱい！'); return false; }
    const key=(type==='tsubasa'?'tsubasa': type==='jump'?'jump':'en');
    const it={type, iconKey:key};
    if(!slots[0]) slots[0]=it; else slots[1]=it;
    refreshSlots(); return true;
  }
  function useItem(i){
    if(state!==ST.RUN) return;
    const it=slots[i]; if(!it) return;
    if(it.type==='tsubasa'){ player.maxJumps=4; player.wingsUntil=t()+5000; showToast('4段ジャンプ！(5s)'); }
    if(it.type==='en'){ world.boostFreeUntil=t()+5000; showToast('ブースト使い放題！(5s)'); }
    if(it.type==='jump'){
      let target=null,dxMin=1e9;
      for(const o of world.obstacles){
        if(o.type==='corn'||o.type==='dokan'){
          const dx=(o.x - (world.scrollX + player.x)); if(dx>0 && dx<dxMin){dxMin=dx; target=o;}
        }
      }
      if(target){ Object.assign(target,{type:'ramp', img:IM.jumpdai, w:180, h:64, ramp:true}); showToast('ジャンプ台に変化！'); }
      else{ showToast('近くに対象なし'); }
    }
    slots[i]=null; refreshSlots();
  }
  function refreshSlots(){
    slotEls.forEach((el,i)=>{
      el.innerHTML='';
      if(!slots[i]){ el.classList.add('empty'); return; }
      el.classList.remove('empty');
      const im=document.createElement('img'); im.src=files[slots[i].iconKey]; el.appendChild(im);
    });
  }

  /* ===== HUD / 演出 ===== */
  function refreshHUD(){
    distPill.textContent = `距離 ${Math.floor(world.meters)} m`;
    spdPill.textContent  = `速度 ${Math.round(world.speed*15)} km/h`;
    const pct = Math.min(100, world.boostGauge/world.boostFillMs*100);
    boostFill.style.width = `${pct}%`;
    boostBar.classList.toggle('boostReady', pct>=100);
    coinPill.textContent  = `コイン ${world.coins}/10`;
  }
  function showToast(msg){ toast.textContent=msg; toast.classList.remove('hidden'); setTimeout(()=>toast.classList.add('hidden'),1600); }
  function showCutin(key){ cutinImg.src = files[key] || ''; cutinBox.classList.remove('hidden'); setTimeout(()=>cutinBox.classList.add('hidden'),2000); }

  /* ===== 生成 ===== */
  function spawnObstacle(x){
    const r=Math.random();
    if(r<0.10){
      world.obstacles.push({type:'ramp', img:IM.jumpdai, x, w:180, h:64, ramp:true});
    }else if(r<0.85){
      world.obstacles.push({type:'corn', img:IM.corn, x, w:56, h:56});
    }else{
      world.obstacles.push({type:'dokan', img:IM.dokan, x, w:60, h:20, phase:0, timer:0, maxH:96});
    }
  }
  function spawnItem(x){
    const gy = seamY();
    const r = Math.random();
    const type = r < 0.34 ? 'tsubasa' : r < 0.67 ? 'jump' : 'en';
    const yBase = gy - rnd(80, 140);
    world.items.push({ type, icon: IM[type==='tsubasa'?'tsubasa':type==='jump'?'jump':'en'], x, y: yBase, w: 44, h: 44, vy: (Math.random()<0.5 ? 0.22 : -0.22) });
  }
  function spawnSign(x){
    const n=rnd(1,6);
    world.signs.push({ img:IM['kanban'+n], x, w:300, h:220 });
  }

  /* ===== ヴィラン ===== */
  let viran=null;
  function callViran(){ showCutin('viranop'); viran={ x:world.scrollX+W*0.80, y:seamY()-260, shoots:0, max:rnd(4,6), nxt: t()+rnd(1300,1700) }; }
  function fireball(x,y){ world.fires.push({x,y,w:26,h:26,vy:1.2}); }

  /* ===== ループ ===== */
  let last = performance.now();
  ready.then(()=>{ show(panelOP); requestAnimationFrame(loop); });
  function loop(now){
    const dt = Math.min(32, now-last); last=now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  /* ===== 更新 ===== */
  function update(dt){
    if(state===ST.RUN){
      world.scrollX += world.speed;
      world.meters  += world.speed*0.06;

      if(!(t()<(world.boostFreeUntil||0)) && !world.boosting){
        world.boostGauge += dt;
        if(world.boostGauge>=world.boostFillMs){ world.boostGauge=world.boostFillMs; world.boostReady=true; }
      }
      if(world.boosting && t()>world.boostUntil){ world.boosting=false; world.speed=world.baseSpeed; }
      if(!viran && world.meters >= world.nextViranAt){ callViran(); world.nextViranAt += rnd(600,1000); }

      if(world.scrollX + W > world.nextSignAtX){ const sx = Math.max(world.scrollX + W + 120, world.nextSignAtX); spawnSign(sx); world.nextSignAtX += rnd(2400,3600); }

      const right = world.scrollX + W + 60;
      if(world.nextObsX < right){ if(world.meters > world.safeUntilMeters-20) spawnObstacle(world.nextObsX); world.nextObsX += rnd(260,420); }
      if(world.nextItemX < right){ spawnItem(world.nextItemX); world.nextItemX += rnd(2200,3400); }
      if(Math.random()<0.0035){ const bx=world.scrollX+W+80, y=seamY()-rnd(120,230), n=rnd(1,3); for(let k=0;k<n;k++){ world.items.push({type:'coin', icon:IM.coin, x:bx+k*46, y, w:30, h:30, vy:0}); } }
    }

    const gy=seamY();
    player.xPrev=player.x; player.yPrev=player.y;
    player.vy += world.gravity; player.y += player.vy;

    if(viran && state===ST.RUN){
      const minX = world.scrollX + W*0.72;
      viran.x = Math.max(viran.x + world.speed*0.4, minX);
      viran.y += (seamY()-260 - viran.y)*0.02;
      if(t()>viran.nxt && viran.shoots<viran.max){ fireball(viran.x-40, viran.y+30); viran.shoots++; viran.nxt = t()+rnd(1300,1700); }
      if(viran.shoots>=viran.max && t()>viran.nxt+900){ viran=null; }
    }

    let topY=gy - player.h;

    for(const o of world.obstacles){
      const ox=o.x-world.scrollX;
      if(o.type==='dokan'){
        o.timer = (o.timer||0) + dt;
        if(o.phase===0){ o.h=(o.h||20)+0.9; if(o.h>=o.maxH){ o.h=o.maxH; o.phase=1; o.timer=0; } }
        else if(o.phase===1){ if(o.timer>2000){ o.phase=2; } }
        else if(o.phase===2){ o.h-=1.2; if(o.h<=20){ o.h=20; o.phase=0; o.timer=0; } }
      }

      const oh=(o.h||20);
      const oy = gy - oh;

      if(o.type==='ramp'){
        // ===== 斜め坂：前低・後高の線形スロープ =====
        const centerX = player.x + player.w*0.5;
        const rel = Math.max(0, Math.min(1, (centerX - ox) / o.w)); // 0..1(台の中)
        const yFront = gy - 14;              // 前端（地面ほぼ沿い）
        const yBack  = gy - oh + 6;          // 後端（やや上）
        const rampTop = yFront + (yBack - yFront) * rel;

        // 上から着地 or 前面から登り始めたら坂に沿って張り付け
        const prevBottom = player.yPrev + player.h;
        const currBottom = player.y + player.h;
        const falling = player.vy >= 0;
        const withinX = centerX >= ox && centerX <= ox + o.w;
        if(withinX && falling && prevBottom <= rampTop && currBottom >= rampTop - 1){
          player.y = rampTop - player.h;
          player.vy = 0;
          player.onGround = true;
          player.jumps = 0;
          // 6割地点を越えたらオートジャンプ発動
          if(rel >= 0.6){
            player.vy = -24; player.onGround=false;
            world.speed = Math.min(world.maxSpeed, world.baseSpeed*2.0);
            world.boosting = true; world.boostUntil = t() + 1000;
          }
        }
        // rampには"側面衝突"の即死は無し（坂として機能）
        continue;
      }

      // Corn / Dokan のAABB
      if(AABB(player.x,player.y,player.w,player.h, ox,oy, o.w,oh)){
        if(state===ST.COUNT || world.meters<world.safeUntilMeters){
          // 無効期間
        } else if(o.type==='corn'){
          hit();
        } else if(o.type==='dokan'){
          // 上からなら乗れる／横は即死
          const prevBottom = player.yPrev + player.h;
          const currBottom = player.y + player.h;
          const falling = player.vy >= 0;
          const landingFromTop = (prevBottom <= oy && currBottom >= oy-2 && falling);
          if(landingFromTop){
            topY = Math.min(topY, oy - player.h);
          }else{
            const sideHit = currBottom > oy + 8;
            if(sideHit) hit();
          }
        }
      }
    }

    // 火の玉＆残骸
    for(let i=world.fires.length-1;i>=0;i--){
      const f=world.fires[i]; f.vy+=0.5; f.y+=f.vy;
      const fx=f.x-world.scrollX, fy=f.y;
      if(fy+f.h>=gy){ world.hazards.push({x:f.x,w:30,h:20}); world.fires.splice(i,1); continue; }
      if(AABB(player.x,player.y,player.w,player.h, fx,fy,f.w,f.h)){ if(world.meters>=world.safeUntilMeters) hit(); world.fires.splice(i,1); }
    }
    for(const hz of world.hazards){
      const hx=hz.x-world.scrollX, hy=gy-hz.h;
      if(AABB(player.x,player.y,player.w,player.h, hx,hy,hz.w,hz.h)){ if(world.meters>=world.safeUntilMeters) hit(); }
    }

    // アイテム取得（PAD）
    if(state===ST.RUN){
      for(let i=world.items.length-1;i>=0;i--){
        const it=world.items[i];
        if(it.vy){ const gy=seamY(); it.y+=it.vy; if(it.y<gy-230 || it.y>gy-80) it.vy*=-1; }
        const ix=it.x-world.scrollX, iy=it.y; const PAD=6;
        if (AABB(player.x-PAD, player.y-PAD, player.w+PAD*2, player.h+PAD*2, ix,iy,it.w,it.h)){
          if(it.type==='coin'){ world.coins++; coinPill.textContent=`コイン ${world.coins}/10`; if(world.coins%10===0){ showCutin('mutekiop'); } }
          else { addItem(it.type); }
          world.items.splice(i,1);
        }else if(ix<-140){ world.items.splice(i,1); }
      }
    }

    // 最終接地
    if(player.y>=topY){ player.y=topY; player.vy=0; player.onGround=true; player.jumps=0; } else { player.onGround=false; }

    refreshHUD();
  }

  /* ===== 描画 ===== */
  function AABB(ax,ay,aw,ah,bx,by,bw,bh){ return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by; }
  function drawTiled(img,y,spd,drawH){
    const iw=img.width||256, scale=Math.max(W/iw,1)*0.6, w=iw*scale;
    const x0=-((world.scrollX*spd)%w);
    for(let x=x0-w;x<W+w;x+=w){ cx.drawImage(img,x,Math.floor(y),Math.floor(w),Math.floor(drawH||img.height*scale)); }
  }

  function render(){
    cx.clearRect(0,0,W,H);

    if(state===ST.TITLE){
      cx.fillStyle="#000"; cx.fillRect(0,0,W,H);
      const s=Math.min(W*0.5,420); cx.globalAlpha=0.95; cx.drawImage(IM.op, (W-s)/2, H*0.28, s, s); cx.globalAlpha=1; return;
    }
    if(state===ST.CHARSEL){ if(IM.sora) cx.drawImage(IM.sora,0,0,W,H); return; }

    if(IM.sora) drawTiled(IM.sora,0,0.12,H);

    const gy=seamY();

    if(IM.field){ const fieldH = Math.max(Math.floor(H*0.23), 90); drawTiled(IM.field, gy - fieldH, 0.55, fieldH); }
    cx.fillStyle = '#111'; cx.fillRect(0, gy, W, H-gy+12);
    if(IM.road) drawTiled(IM.road, gy, 1.0, H-gy+12);

    // 看板
    for(const s of world.signs){
      const x=s.x-world.scrollX, y=gy - s.h - 10 + GROUND_VISUAL_OFFSET;
      cx.drawImage(s.img, Math.floor(x), Math.floor(y), s.w, s.h);
    }

    // アイテム／コイン
    for(const it of world.items){
      const x=it.x-world.scrollX; cx.drawImage(it.type==='coin'?IM.coin:it.icon, Math.floor(x), Math.floor(it.y), it.w, it.h);
    }

    // 障害物（見た目は地面にピタッ）
    for(const o of world.obstacles){
      const x=o.x-world.scrollX;
      if(o.type==='dokan'){ const h=o.h||20; cx.drawImage(IM.dokan, Math.floor(x), Math.floor(gy-h)+GROUND_VISUAL_OFFSET, o.w, h); }
      else if(o.type==='corn'){ cx.drawImage(IM.corn, Math.floor(x), Math.floor(gy-o.h)+GROUND_VISUAL_OFFSET, o.w, o.h); }
      else if(o.type==='ramp'){
        // 画像を少し回転させて“斜め”表現
        const yTop = gy - o.h + GROUND_VISUAL_OFFSET;
        const angle = -12 * Math.PI/180; // -12°
        cx.save();
        cx.translate(Math.floor(x), Math.floor(yTop + o.h)); // 左下を原点に
        cx.rotate(angle);
        cx.drawImage(IM.jumpdai, 0, -o.h, o.w, o.h);
        cx.restore();
      }
    }

    // ヴィラン・弾・残骸
    if(viran){ const vx=viran.x-world.scrollX; const vw=120, vh=120;
      cx.drawImage(IM.viran, Math.floor(vx - vw/2), Math.floor(gy - 260 - vh/2), vw, vh); }
    for(const f of world.fires){ const fx=f.x-world.scrollX; cx.drawImage(IM.tama, Math.floor(fx), Math.floor(f.y), f.w, f.h); }
    for(const hz of world.hazards){ const hx=hz.x-world.scrollX, hy=gy-hz.h; cx.fillStyle='#f54'; cx.fillRect(Math.floor(hx), Math.floor(hy), hz.w, hz.h); }

    // プレイヤー（見た目を下に寄せて“浮き”解消）
    const px=player.x, py=player.y + GROUND_VISUAL_OFFSET;
    if(player.gold){
      cx.drawImage(IM.gold, Math.floor(px-8), Math.floor(py-6), player.w+16, player.h+12);
      const star=(Math.floor(performance.now()/120)%2)?IM.hoshi1:IM.hoshi2;
      for(let i=0;i<3;i++){ const sx=px+(i*16)%player.w, sy=py-10-(i*6); cx.drawImage(star, Math.floor(sx), Math.floor(sy), 16,16); }
    }else{
      cx.drawImage(IM[player.sprite], Math.floor(px), Math.floor(py), player.w, player.h);
    }
  }

  /* ===== 一撃ゲームオーバー ===== */
  function hit(){
    if(state!==ST.RUN) return;
    showToast('ダメージ！');
    state=ST.OVER;
    resultMsg.textContent=`ゲームオーバー\n記録 ${Math.floor(world.meters)} m`;
    resultMsg.classList.remove('hidden');
    setTimeout(()=>{ resultMsg.classList.add('hidden'); show(panelMenu); state=ST.MENU; },2000);
  }

})();
</script>
</body>
</html>
