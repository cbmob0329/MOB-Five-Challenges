<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>MOB CART Runner</title>
<style>
  :root{--fg:#fff;--pill:#2b2f3a;--btn:#1b1f27;--btn2:#2b303b;}
  html,body{margin:0;height:100%;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,'Hiragino Sans','Yu Gothic',sans-serif}
  #wrap{position:fixed;inset:0;overflow:hidden}
  #stage{position:absolute;left:0;top:0;width:414px;height:896px;transform-origin:0 0}
  #cv{display:block;touch-action:none;background:#000}

  .hud{position:absolute;inset:0;pointer-events:none}
  .top{position:absolute;left:10px;right:10px;top:8px;display:flex;gap:10px;align-items:center}
  .pill{background:var(--pill);border-radius:999px;padding:6px 12px;font-weight:700;font-size:14px}
  .mid{position:absolute;left:10px;right:10px;top:42px;display:flex;align-items:center;gap:10px}
  .gauge{height:16px;background:#303847;border:1px solid #475268;border-radius:999px;overflow:hidden;width:100%}
  .gauge i{display:block;height:100%;width:0%;background:linear-gradient(90deg,#2bd,#8ef)}

  .bottom{position:absolute;left:10px;right:10px;bottom:calc(12px + env(safe-area-inset-bottom));display:grid;grid-template-columns:1fr 64px 64px 1fr;gap:10px;pointer-events:none;z-index:5}
  .bbtn{pointer-events:auto;background:var(--btn2);border-radius:16px;padding:14px 12px;font-weight:900;text-align:center}
  .slot{pointer-events:auto;height:56px;border-radius:12px;border:1px dashed #666;background:rgba(255,255,255,.06);display:grid;place-items:center}
  .slot img{max-width:90%;max-height:90%;image-rendering:pixelated}
  .slot.empty{opacity:.35}
  .hidden{display:none !important}

  .center{position:absolute;inset:0;display:grid;place-items:center;pointer-events:none;z-index:6}
  .panel{pointer-events:auto;width:min(94%,560px);background:rgba(15,18,26,.92);border-radius:18px;padding:18px}
  .charWrap{display:flex;gap:10px}
  .card{flex:1 1 48%;border:1px solid #2c3444;border-radius:14px;padding:10px;display:grid;place-items:center;cursor:pointer}
  .card img{width:110px;height:auto;image-rendering:pixelated}
  .sel{outline:3px solid #2bd36b}
  .btn{pointer-events:auto;background:#1b1f27;border:1px solid #323a49;border-radius:14px;padding:12px 16px;font-weight:800;text-align:center;margin-top:12px;cursor:pointer}
  .count{position:absolute;inset:0;display:grid;place-items:center;font-size:60px;font-weight:900;text-shadow:0 4px 16px #000;z-index:7}
  .cutin{position:absolute;inset:auto 50% 40% 50%;transform:translate(-50%,0);z-index:7}
  .cutin img{width:min(80vw,520px);height:auto;display:block;opacity:0;animation:cut 2s ease forwards;image-rendering:pixelated}
  @keyframes cut{0%{opacity:0}15%{opacity:1}85%{opacity:1}100%{opacity:0}}

  /* OP（2秒だけ・軽量） */
  #opOverlay{position:fixed;inset:0;background:#000;display:grid;place-items:center;z-index:20}
  #opOverlay img{width:min(72vw,520px);height:auto;image-rendering:pixelated}
</style>
</head>
<body>
<div id="wrap">
  <div id="stage">
    <canvas id="cv"></canvas>

    <div class="hud">
      <div class="top">
        <div class="pill" id="distPill">距離 0 m</div>
        <div class="pill" id="spdPill">速度 0 km/h</div>
        <div class="pill" id="jumpPill">ジャンプ ×2</div>
        <div class="pill" id="coinPill">コイン 0/10</div>
      </div>
      <div class="mid"><div class="gauge"><i id="boostFill"></i></div></div>

      <div class="bottom">
        <div class="bbtn" id="btnJump">ジャンプ</div>
        <div class="slot empty" id="slot1"></div>
        <div class="slot empty" id="slot2"></div>
        <div class="bbtn" id="btnBoost">ブースト</div>
      </div>

      <div class="center">
        <div class="panel hidden" id="panelChar">
          <h2>キャラクター選択</h2>
          <div class="charWrap">
            <div class="card sel" data-char="orange">
              <img src="orange.png"><div>オレンジ</div>
            </div>
            <div class="card" data-char="VR">
              <img src="VR.png"><div>VR</div>
            </div>
          </div>
          <div class="btn" id="charStart">スタート</div>
        </div>
      </div>

      <div class="count hidden" id="count">3</div>
      <div class="cutin hidden" id="cutin"><img id="cutinImg" src=""></div>
      <div class="result hidden" id="resultMsg"></div>
    </div>
  </div>
</div>

<div id="opOverlay"><img src="op.png" alt=""></div>

<script>
(() => {
  /* ===== スケール（スマホはcoverで全画面・HUDはsafe-area内） ===== */
  const DESIGN_W=414, DESIGN_H=896;
  const stage=document.getElementById('stage');
  function scaleCover(){
    const vw=innerWidth, vh=(visualViewport?visualViewport.height:innerHeight);
    const s=Math.max(vw/DESIGN_W, vh/DESIGN_H); // cover
    const tx=(vw-DESIGN_W*s)/2, ty=(vh-DESIGN_H*s)/2;
    stage.style.transform=`translate(${tx}px,${ty}px) scale(${s})`;
  }
  addEventListener('resize',scaleCover,{passive:true});
  if (window.visualViewport) visualViewport.addEventListener('resize',scaleCover,{passive:true});
  scaleCover();

  /* ===== Canvas ===== */
  const cv=document.getElementById('cv'), cx=cv.getContext('2d');
  const DPR=Math.min(2, devicePixelRatio||1);
  cv.width=Math.round(DESIGN_W*DPR); cv.height=Math.round(DESIGN_H*DPR);
  cv.style.width=DESIGN_W+'px'; cv.style.height=DESIGN_H+'px';
  cx.setTransform(DPR,0,0,DPR,0,0);
  const W=DESIGN_W,H=DESIGN_H;

  /* ===== 画像 ===== */
  const files={
    doro:'do-ro.png', hatake:'hatake2.png', sora:'sora.PNG',
    corn:'corn.PNG', dokan:'dokan.png', jumpdai:'jumpdai.png',
    orange:'orange.png', VR:'VR.png'
  };
  const IM={}; for(const[k,src] of Object.entries(files)){ const img=new Image(); img.src=src; IM[k]=img; }

  /* ===== 定数・状態 ===== */
  const ROAD_TOP_Y=(H*0.82)|0, ROAD_BASELINE_OFFSET=12;
  const GROUND_Y=()=>ROAD_TOP_Y+ROAD_BASELINE_OFFSET;
  const CORN_Y_OFFSET=4;

  const world={scrollX:0, speed:3.6, meters:0, gravity:0.72, obstacles:[], nextObsX:W+360};
  const player={x:(W*0.22)|0, y:0, w:48, h:54, vy:0, onGround:true, sprite:'orange', prevY:0, prevX:0, tilt:0};
  const ST={TITLE:0, CHARSEL:1, COUNT:2, RUN:3, OVER:4}; let state=ST.TITLE;

  /* ===== OP 2秒 → キャラ選択 ===== */
  const op=document.getElementById('opOverlay');
  setTimeout(()=>{ op.style.display='none'; show(panelChar); state=ST.CHARSEL; }, 2000);

  /* ===== UI ===== */
  const panelChar=document.getElementById('panelChar');
  function show(el){el.classList.remove('hidden')} function hide(el){el.classList.add('hidden')}

  // カード選択（←これが無くて選べなかった）
  let selected='orange';
  panelChar.addEventListener('click',e=>{
    const card=e.target.closest('.card'); if(!card) return;
    selected=card.dataset.char;
    panelChar.querySelectorAll('.card').forEach(c=>c.classList.toggle('sel', c===card));
  });

  // Startは状態に関係なく動くように（edgeケースで無効化されない）
  document.getElementById('charStart').addEventListener('click', ()=>{
    player.sprite=selected; hide(panelChar); startCountdown();
  });

  // 入力
  document.getElementById('btnJump').addEventListener('touchstart',e=>{e.preventDefault();jump();},{passive:false});
  document.getElementById('btnJump').addEventListener('mousedown',e=>{e.preventDefault();jump();});
  addEventListener('keydown',e=>{ if(e.code==='Space'||e.code==='ArrowUp'){e.preventDefault();jump();} });

  function startCountdown(){
    state=ST.COUNT;
    let n=3; const el=document.getElementById('count'); el.textContent=n; show(el);
    const tm=setInterval(()=>{ n--; if(n>0) el.textContent=n; else if(n===0) el.textContent='GO';
      else{ clearInterval(tm); hide(el); startRun(); } },700);
  }

  function startRun(){
    state=ST.RUN; world.scrollX=0; world.meters=0; world.obstacles.length=0; world.nextObsX=W+360;
    player.vy=0; player.y=GROUND_Y()-player.h; player.prevY=player.y; player.prevX=player.x; player.tilt=0;
    requestAnimationFrame(loop);
  }

  /* ===== 生成 ===== */
  function makeCorn(x){ return {type:'corn', x, w:78, h:78, hit:{x:8,y:8,w:62,h:60}}; }
  function makePipe(x){ return {type:'dokan', x, w:66, h:22, phase:0, timer:0, maxH:104}; }
  function makeRamp(x){ // 三角ウェッジ
    const w=120,h=36,launch=0.6;
    return {type:'ramp', x, w, h, launchX:x + w*launch, launched:false, slope:h/(w*launch)};
  }

  /* ===== 物理 ===== */
  function jump(){ if(state!==ST.RUN) return; if(player.onGround){ player.vy=-14; player.onGround=false; } }

  function update(dt){
    if(state!==ST.RUN) return;
    world.scrollX += world.speed;
    world.meters  += world.speed*0.06;

    // スポーン
    const right=world.scrollX+W+40;
    if(world.nextObsX<right){
      const r=Math.random();
      world.obstacles.push( r<0.33? makeRamp(world.nextObsX) : r<0.7? makeCorn(world.nextObsX) : makePipe(world.nextObsX) );
      world.nextObsX += (360 + Math.random()*220)|0;
    }

    // プレイヤー
    player.prevX=player.x; player.prevY=player.y;
    player.vy += world.gravity; player.y += player.vy; player.onGround=false;

    const gy=GROUND_Y(); let topY=gy - player.h;

    // 障害物
    for(const o of world.obstacles){
      const ox=(o.x - world.scrollX)|0;

      // 土管の伸縮
      if(o.type==='dokan'){
        o.timer+=dt;
        if(o.phase===0){ o.h=(o.h||22)+0.9; if(o.h>=o.maxH){ o.h=o.maxH; o.phase=1; o.timer=0; } }
        else if(o.phase===1){ if(o.timer>1800){ o.phase=2; } }
        else if(o.phase===2){ o.h-=1.2; if(o.h<=22){ o.h=22; o.phase=0; o.timer=0; } }
      }

      // ジャンプ台（三角傾斜に吸着→60%で自動ジャンプ）
      if(o.type==='ramp'){
        const startX=ox, endX=(o.launchX - world.scrollX)|0;
        const feetX = player.x + (player.w>>1);
        if(feetX>=startX && feetX<=startX + o.w*0.98){
          const climbLen=Math.max(1,(endX-startX));
          const ratio=Math.min(1,Math.max(0,(feetX-startX)/climbLen));
          const rampY=(gy - o.h*ratio)|0;
          const feetPrev=player.prevY+player.h, feet=player.y+player.h;
          const onRamp=(feet>=rampY-10 && feet<=rampY+10) || (feetPrev<=rampY && feet>=rampY);
          if(onRamp){
            player.y = (rampY - player.h)|0;
            player.vy = Math.max(player.vy,0);
            player.onGround=true;
            player.tilt = -Math.atan(o.slope);
            topY = Math.min(topY, player.y);
          }
        }
        if(!o.launched && feetX > endX){ o.launched=true; player.vy=-18; }
      }

      // 土管：上は吸着 / 横・下はアウト（±12px）
      if(o.type==='dokan'){
        const h=o.h||22, left=ox, top=gy-h, right=left+o.w, bottom=top+h;
        if(AABB(player.x,player.y,player.w,player.h,left,top,o.w,h)){
          const prevB=player.prevY+player.h, nowB=player.y+player.h;
          const prevR=player.prevX+player.w, nowR=player.x+player.w;
          const fromTop = (prevB<=top+12) && (nowB>=top) &&
                          ((player.x+player.w*0.5)>=left && (player.x+player.w*0.5)<=right);
          const hitSide = (prevR<=left && nowR>left) || (player.prevX>=right && player.x<right);
          const fromBottom = (player.prevY<=bottom && player.y<bottom && nowB>bottom);
          if(fromTop){
            player.y = (top - player.h)|0; player.vy=0; player.onGround=true; topY=Math.min(topY,player.y);
          }else if(hitSide||fromBottom){ gameOver(); return; }
        }
      }

      // コーン：地面ベタ置き（4px沈め）＋内側判定
      if(o.type==='corn'){
        const oy=(gy - o.h + CORN_Y_OFFSET)|0;
        const bx=ox + o.hit.x, by=oy + o.hit.y, bw=o.hit.w, bh=o.hit.h;
        if(AABB(player.x,player.y,player.w,player.h,bx,by,bw,bh)){ gameOver(); return; }
      }
    }

    // 地面吸着
    const gyTop=gy - player.h;
    if(player.y>=gyTop){ player.y=gyTop; player.vy=0; player.onGround=true; player.tilt += (0 - player.tilt)*0.2; }
    else { player.onGround=false; player.tilt += (0 - player.tilt)*0.1; }
  }

  function render(){
    cx.clearRect(0,0,W,H);
    // 背景
    if(IM.sora.complete) cx.drawImage(IM.sora,0,0,W,H);
    const gy=GROUND_Y();
    // 畑（上端を道路に3px重ね）
    if(IM.hatake.complete) cx.drawImage(IM.hatake,0,(gy-200-3)|0, W, 200+3);
    // 道路
    if(IM.doro.complete) cx.drawImage(IM.doro,0,ROAD_TOP_Y,W,H-ROAD_TOP_Y);

    // 障害物描画
    for(const o of world.obstacles){
      const x=(o.x - world.scrollX)|0;
      if(o.type==='dokan'){ const h=o.h||22; if(IM.dokan.complete) cx.drawImage(IM.dokan,x,(gy-h)|0,o.w,h); }
      if(o.type==='corn'){ if(IM.corn.complete) cx.drawImage(IM.corn,x,(gy-o.h + CORN_Y_OFFSET)|0,o.w,o.h); }
      if(o.type==='ramp'){
        // 三角ウェッジをテクスチャで塗る（jumpdai.png）
        const y=gy, w=o.w, h=o.h;
        if(IM.jumpdai.complete){
          // 斜面に沿って小タイルを敷く簡易描画
          cx.save();
          cx.beginPath();
          cx.moveTo(x,y); cx.lineTo(x+w,y); cx.lineTo(x,y-h); cx.closePath();
          const pat=cx.createPattern(IM.jumpdai,'repeat');
          cx.fillStyle=pat; cx.fill();
          cx.restore();
        }else{
          cx.fillStyle='#7cf'; cx.beginPath(); cx.moveTo(x,y); cx.lineTo(x+w,y); cx.lineTo(x,y-h); cx.closePath(); cx.fill();
        }
      }
    }

    // プレイヤー
    cx.save();
    const px=player.x + (player.w/2)|0, py=(player.y+player.h)|0;
    cx.translate(px,py); cx.rotate(player.tilt);
    const spr=IM[player.sprite]; if(spr.complete) cx.drawImage(spr,(-player.w/2)|0,(-player.h)|0,player.w,player.h);
    cx.restore();
  }

  function loop(ts){
    const dt = Math.min(32, ts-(loop._||ts)); loop._=ts;
    update(dt); render(); if(state===ST.RUN) requestAnimationFrame(loop);
  }

  function gameOver(){
    state=ST.OVER;
    const el=document.getElementById('resultMsg');
    el.textContent=`ゲームオーバー\n記録 ${Math.floor(world.meters||0)} m`;
    el.classList.remove('hidden');
    setTimeout(()=>{ el.classList.add('hidden'); show(panelChar); state=ST.CHARSEL; }, 1500);
  }

  function AABB(ax,ay,aw,ah,bx,by,bw,bh){return ax<bx+bw && ax+aw>bx && ay<by+bh && ay+ah>by;}
})();
</script>
</body>
</html>
