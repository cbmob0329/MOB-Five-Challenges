<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>MOB CART Runner — v3 安定版（地形/密着/サイズ 最終修正）</title>
<style>
  :root{
    --ui-fg:#fff; --ui-dim:#9fb0ce; --line:#2b3342;
    --safe-top: env(safe-area-inset-top,0px); --safe-bottom: env(safe-area-inset-bottom,0px);
  }
  html,body{margin:0;height:100%;background:#000;color:var(--ui-fg);font-family:-apple-system,system-ui,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif;}
  *{box-sizing:border-box}
  button{touch-action:manipulation;-webkit-user-select:none;user-select:none}
  #app{position:fixed;inset:0;overflow:hidden}

  /* Top bar */
  .topbar{position:fixed;inset:0 0 auto 0;z-index:50;display:flex;gap:12px;align-items:center;
    padding:calc(8px + var(--safe-top)) 12px 8px;background:rgba(11,15,20,.9);backdrop-filter:blur(8px)}
  .title{line-height:1.05}
  .title b{font-size:16px}
  .title small{display:block;color:var(--ui-dim);font-size:11px}
  .right{margin-left:auto}
  .ghost{background:#0f141b;border:1px solid var(--line);color:#dfe7f7;border-radius:14px;padding:8px 12px;font-size:13px}

  /* HUD */
  .hud{position:fixed;top:calc(48px + var(--safe-top));left:0;right:0;z-index:45;display:flex;gap:10px;align-items:center;padding:8px 12px;pointer-events:none}
  .pill{pointer-events:auto;min-width:72px;padding:8px 12px;border-radius:18px;background:#182028;border:1px solid var(--line)}
  .pill h6{margin:0;font-size:10px;color:var(--ui-dim)}
  .pill .v{font-size:14px;margin-top:2px}
  .meter{width:16px;height:44px;border-radius:12px;background:#111823;border:1px solid var(--line);position:relative;overflow:hidden}
  .meter .fill{position:absolute;left:2px;right:2px;bottom:2px;height:0;border-radius:10px;background:linear-gradient(#6ee7ff,#38bdf8)}
  .meter.ready{box-shadow:0 0 0 2px rgba(43,211,255,.15),0 0 14px rgba(55,194,255,.35) inset}
  .btn-mini{pointer-events:auto;margin-left:auto}

  /* Canvas */
  #stageWrap{position:fixed;inset:0;z-index:10}
  #cv{width:100%;height:100%;display:block;background:#000;touch-action:none}

  /* Bottom controls */
  .controls{position:fixed;left:0;right:0;bottom:0;z-index:100;display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px;
    padding:10px 12px calc(10px + var(--safe-bottom));pointer-events:auto}
  .cbtn{border-radius:16px;padding:14px 10px;border:1px solid var(--line);background:#0e1218;box-shadow:0 8px 24px rgba(0,0,0,.35);color:#dfe7f7;font-size:15px}
  .cbtn:active{transform:translateY(1px)}
  .jump{background:#0f1523}
  .boost{background:#1a0f12}
  .item{background:#0f171a}
  .cbtn[disabled]{opacity:.35}

  /* Overlays */
  .cut{position:fixed;inset:0;z-index:90;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .cut img{max-width:70vw;max-height:60vh;filter:drop-shadow(0 10px 24px rgba(0,0,0,.55));opacity:0;transform:scale(.95);transition:.25s}
  .cut.show img{opacity:1;transform:scale(1)}
  .countdown{position:fixed;inset:0;z-index:80;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:64px;letter-spacing:2px;text-shadow:0 8px 30px rgba(0,0,0,.6);opacity:0;transition:.2s}
  .countdown.show{opacity:1}

  .centerModal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:120}
  .card{background:#0b0f15;border:1px solid #253044;border-radius:16px;padding:16px;min-width:260px;box-shadow:0 12px 36px rgba(0,0,0,.5)}
  .row{display:flex;gap:10px;align-items:center;justify-content:center}
  .opt{border:1px solid var(--line);background:#0d121a;border-radius:12px;padding:8px 10px}
  .opt img{height:64px}
  .stack{display:flex;gap:10px;justify-content:center;margin-top:10px}
</style>
</head>
<body>
  <div id="app">
    <div class="topbar">
      <div class="title"><b>MOB CART Runner</b><small>v3 安定版（地形/密着/サイズ 最終修正）</small></div>
      <div class="right"><button id="btnFS" class="ghost">全画面</button></div>
    </div>

    <div class="hud">
      <div class="pill"><h6>距離</h6><div class="v" id="hudDist">0 m</div></div>
      <div class="pill"><h6>速度</h6><div class="v" id="hudSpeed">0 km/h</div></div>
      <div class="pill"><h6>ジャンプ</h6><div class="v" id="hudJump">×2</div></div>
      <div class="meter" id="hudBoost"><div class="fill"></div></div>
      <div class="pill" id="hudCoin"><h6>コイン</h6><div class="v">0/10</div></div>
      <div class="btn-mini"><button id="btnChange" class="ghost">キャラ変更</button></div>
    </div>

    <div id="stageWrap"><canvas id="cv" width="540" height="960"></canvas></div>

    <div class="controls">
      <button id="btnJump"  class="cbtn jump">ジャンプ</button>
      <button id="btnBoost" class="cbtn boost">ブースト</button>
      <button id="btnItem1" class="cbtn item" disabled>アイテム1</button>
      <button id="btnItem2" class="cbtn item" disabled>アイテム2</button>
    </div>

    <div class="cut" id="cut"><img id="cutImg" alt=""></div>
    <div class="countdown" id="countdown">3</div>

    <div class="centerModal" id="charSel" style="display:none">
      <div class="card">
        <div style="font-size:20px;font-weight:700;margin-bottom:8px">キャラ選択</div>
        <div class="row">
          <button class="opt" data-ch="orange"><img src="orange.png" alt="orange"></button>
          <button class="opt" data-ch="VR"><img src="VR.png" alt="VR"></button>
        </div>
        <div class="stack"><button id="btnStart" class="cbtn">スタート</button></div>
      </div>
    </div>

    <div class="centerModal" id="gameOver" style="display:none">
      <div class="card">
        <div id="goMsg" style="font-size:22px;font-weight:700;margin-bottom:6px">記録 0m！</div>
        <div class="stack" style="margin-top:8px">
          <button id="goRestart" class="cbtn">スタート</button>
          <button id="goChange"  class="cbtn">キャラ選択</button>
          <button id="goQuit"    class="cbtn">やめる</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  /* ====== Canvas / layout ====== */
  const cv = document.getElementById('cv'), ctx = cv.getContext('2d');
  let vw=cv.width|0, vh=cv.height|0;
  function fit(){
    vw = cv.width  = Math.max(540, Math.min(720, Math.round(window.innerWidth  * 1)));
    vh = cv.height = Math.max(900, Math.min(1200,Math.round(window.innerHeight * 1)));
  }
  addEventListener('resize', fit); fit();

  /* ====== UI refs ====== */
  const elDist = document.getElementById('hudDist');
  const elSpeed= document.getElementById('hudSpeed');
  const elJump = document.getElementById('hudJump');
  const elBoost= document.getElementById('hudBoost');
  const elBoostFill = elBoost.querySelector('.fill');
  const elCoin = document.getElementById('hudCoin').querySelector('.v');
  const btnFS = document.getElementById('btnFS');
  const btnChange = document.getElementById('btnChange');
  const btnJump  = document.getElementById('btnJump');
  const btnBoost = document.getElementById('btnBoost');
  const btnItem1 = document.getElementById('btnItem1');
  const btnItem2 = document.getElementById('btnItem2');
  const charSel = document.getElementById('charSel');
  const startBtn= document.getElementById('btnStart');
  const goModal = document.getElementById('gameOver');
  const goMsg   = document.getElementById('goMsg');
  const goRestart = document.getElementById('goRestart');
  const goChange  = document.getElementById('goChange');
  const goQuit    = document.getElementById('goQuit');
  const cut = document.getElementById('cut'), cutImg = document.getElementById('cutImg');
  const countdown = document.getElementById('countdown');

  /* ====== Assets ====== */
  const files = [
    'sora.PNG','hatake2.png','hatake.png','do-ro.png',
    'corn.PNG','dokan.png','jumpdai.png',
    'orange.png','VR.png','op.png',
    'kanban1.png','kanban2.png','kanban3.png','kanban4.png','kanban5.png','kanban6.png',
    'coin.png','gold.png','hoshi1.png','hoshi2.png','mutekiop.png','viran op.png','viran.png','tama.png',
    'tsubasa.png','jump.png','en.png',
    'gomi.png','contena.png','tora.png'
  ];
  const IMG={}; let left = files.length;
  files.forEach(fn=>{ const im=new Image(); im.src = encodeURI(fn); im.onload=()=>{IMG[fn]=im;if(--left===0) boot();}; im.onerror=()=>{IMG[fn]=im;if(--left===0) boot();}; });

  /* ====== World constants ====== */
  const GY = ()=> Math.floor(vh*0.80);          // 地面上端（走行ラインの基準）
  const RUNX = ()=> Math.floor(vw*0.25);        // プレイヤーの固定X
  const SAFE_M = 80;                            // スタート安全地帯
  const KMH_PER_PX = 0.06*3.6;

  // 画像の論理サイズ（大きめ）
  const SIZE = {
    player:{w:90,h:64},
    corn:{w:64,h:86},
    gomi:{w:84,h:78},
    cont:{w:128,h:120},
    tora:{w:140,h:96},
    dokan:{w:96,h:160}, // 最大時
    jump:{w:200,h:64},
    kanban:{w:432,h:324},
    coin:{w:26,h:26},
    item:{w:34,h:34}
  };

  /* ====== State ====== */
  let state='boot';
  let scrollX=0, meters=0;
  let baseSpeed=180, speed=baseSpeed;
  let boostGauge=100, boostMax=100, boosting=0, enFree=0, invincible=0, wingTime=0;
  let coins=0, needCoin=10, sparkleT=0, sparkleFrame=0;
  let nextVillAtM = 1200 + Math.random()*800;

  const player = { sprite:'orange.png', w:SIZE.player.w, h:SIZE.player.h, x:RUNX()|0, y:(GY()-SIZE.player.h)|0, vy:0, onGround:true, jumpsLeft:2, tilt:0 };

  const items=[], obstacles=[], fires=[], villains=[];
  const slots=[null,null];
  const clamp=(v,a,b)=>v<a?a:(v>b?b:v);
  const rects=(a,b)=>!(a.x+a.w<b.x||b.x+b.w<a.x||a.y+a.h<b.y||b.y+b.h<a.y);

  /* ====== UI ====== */
  btnFS.addEventListener('click',()=>{
    const el=document.documentElement;
    if(!document.fullscreenElement){ el.requestFullscreen?.(); btnFS.textContent='全画面解除'; } else { document.exitFullscreen?.(); btnFS.textContent='全画面'; }
  });
  function showCut(fn,ms=2000){ cutImg.src=encodeURI(fn); cut.classList.add('show'); setTimeout(()=>cut.classList.remove('show'),ms); }
  function showCountdown(seq=['3','2','1','GO'],step=700,cb){
    let i=0; const tick=()=>{ countdown.textContent=seq[i]; countdown.classList.add('show');
      setTimeout(()=>countdown.classList.remove('show'), step-150);
      if(++i<seq.length) setTimeout(tick,step); else setTimeout(cb,step);
    }; tick();
  }
  function tileX(img, y, h, factor, overlapTop=0){
    if(!(img&&img.width)) return;
    y = (y-overlapTop)|0; h = (h+overlapTop)|0; // 1px重ねで隙間対策
    const aspect = img.width/img.height;
    const pw = Math.max(16, Math.round(h * aspect));
    const tx = - ((scrollX*factor) % pw);
    for(let x=tx-pw; x<vw+pw; x+=pw){ ctx.drawImage(img, x|0, y|0, pw|0, h|0); }
  }

  /* ====== Spawner ====== */
  let lastSpawnAt = -9999, lastKind='';
  let lastKanbanAt = -99999; // 看板間距離
  function canSpawn(kind){
    const dx = (scrollX - lastSpawnAt);
    const need = (kind===lastKind)? 520:380; // 全体間隔
    return dx>need;
  }
  function spawnAt(kind,x){
    const gy=GY()|0;
    if(kind==='corn'){ obstacles.push({kind,x:x|0,y:(gy-SIZE.corn.h)|0,w:SIZE.corn.w,h:SIZE.corn.h, deadly:true}); }
    else if(kind==='gomi'){ obstacles.push({kind,x:x|0,y:(gy-SIZE.gomi.h)|0,w:SIZE.gomi.w,h:SIZE.gomi.h, deadly:true, t:Math.random()*6}); }
    else if(kind==='contena'){ const n=(Math.random()<.5?2:3); for(let i=0;i<n;i++) obstacles.push({kind,x:(x+i*(SIZE.cont.w+8))|0,y:(gy-SIZE.cont.h)|0,w:SIZE.cont.w,h:SIZE.cont.h, deadlySide:true}); }
    else if(kind==='tora'){ obstacles.push({kind,x:x|0,y:(gy-SIZE.tora.h)|0,w:SIZE.tora.w,h:SIZE.tora.h, deadlySide:true, cool:0}); }
    else if(kind==='dokan'){ obstacles.push({kind,x:x|0,baseY:gy,phase:0,y:(gy-30)|0,w:SIZE.dokan.w,h:30, deadlySide:true}); }
    else if(kind==='jumpdai'){ obstacles.push({kind,x:x|0,y:(gy-SIZE.jump.h)|0,w:SIZE.jump.w,h:SIZE.jump.h, kicked:false}); }
    else if(kind==='kanban'){ const nowX = scrollX|0; if(nowX-lastKanbanAt<1200) return; lastKanbanAt = nowX;
      const i=1+Math.floor(Math.random()*6); obstacles.push({kind,img:'kanban'+i+'.png',x:x|0,y:(gy-SIZE.kanban.h)|0,w:SIZE.kanban.w,h:SIZE.kanban.h}); }
  }
  function weightedPick(weights){ const sum=weights.reduce((a,b)=>a+b[1],0); let r=Math.random()*sum; for(const w of weights){ r-=w[1]; if(r<=0) return w[0]; } return weights[0][0]; }
  function spawnRandom(){
    const m=meters;
    const pool = (m<SAFE_M)
      ? [['jumpdai',3],['kanban',0.12]]
      : [['corn',3],['gomi',3],['contena',3],['tora',2],['dokan',2],['jumpdai',2],['kanban',0.12]];
    const kind = weightedPick(pool);
    if(!canSpawn(kind)) return;
    spawnAt(kind, scrollX + vw + 160 + Math.random()*260);
    lastSpawnAt = scrollX; lastKind = kind;
  }

  // コインはレア：確率 0.004、前回から400m空け、クラスター同時1つまで
  let lastCoinAtM = -9999;
  function spawnCollectibles(){
    const already = items.some(it=>it.type==='coin');
    if(!already && Math.random()<0.004 && meters-lastCoinAtM>400){
      const gy=GY(), n=(Math.random()<.5?3:5), start=scrollX+vw+180+Math.random()*260, baseY=gy-160-Math.random()*90;
      for(let i=0;i<n;i++) items.push({type:'coin',x:(start+i*32)|0,y:(baseY+Math.sin(i)*8)|0,w:SIZE.coin.w,h:SIZE.coin.h});
      lastCoinAtM = meters;
    }
    // レアアイテムは以前どおり（低頻度）
    if(Math.random()<0.006){
      const type=['tsubasa','jump','en'][Math.floor(Math.random()*3)];
      const gy=GY(); items.push({type, x:(scrollX+vw+200+Math.random()*260)|0, y:(gy-190-Math.random()*90)|0, w:SIZE.item.w,h:SIZE.item.h, t:Math.random()*6});
    }
  }

  /* ====== Villain ====== */
  function maybeVillain(){
    if(meters>=nextVillAtM && villains.length===0){
      showCut('viran op.png',2000);
      setTimeout(()=>{
        villains.push({x:scrollX+RUNX()+260, y:-80, vy:20, state:'descend', hoverY:GY()-220, left:5+Math.floor(Math.random()*4), t:1});
      },450);
      nextVillAtM += 1000 + Math.random()*1000;
    }
  }
  function updateVill(dt){
    for(const v of villains){
      if(v.state==='descend'){ v.y += v.vy*dt; if(v.y>=v.hoverY){ v.y=v.hoverY; v.state='hover'; } }
      else if(v.state==='hover'){
        const targetX = scrollX + RUNX() + 260;
        v.x += (targetX - v.x)*0.03;
        v.t -= dt; if(v.t<=0){ v.state='throw'; v.t = .9 + Math.random()*0.9; }
      }
      else if(v.state==='throw'){
        const tx = scrollX + RUNX() + 80 + Math.random()*140;
        fires.push({x:v.x,y:v.y+18,vx:(tx-v.x)*0.6,vy:40,ay:520,w:34,h:34,landed:false});
        v.left--; v.state='hover'; if(v.left<=0) v.state='ascend';
      }
      else if(v.state==='ascend'){ v.y -= 18*dt*60; if(v.y<-120) v.state='done'; }
    }
    while(villains.length && villains[0].state==='done') villains.shift();
  }

  /* ====== Input（pointerdownで確実に） ====== */
  const onPD=(el,fn)=>el.addEventListener('pointerdown',e=>{e.preventDefault(); fn();},{passive:false});
  onPD(btnJump,  ()=>jump());
  onPD(btnBoost, ()=>boost());
  onPD(btnItem1, ()=>useSlot(0));
  onPD(btnItem2, ()=>useSlot(1));
  btnChange.addEventListener('click',()=>openSelect());
  document.querySelectorAll('#charSel .opt').forEach(b=>{
    b.addEventListener('click',()=>{
      const ch=b.dataset.ch; player.sprite=(ch==='VR')?'VR.png':'orange.png';
      document.querySelectorAll('#charSel .opt').forEach(x=>x.style.outline=''); b.style.outline='2px solid #2bd3ff';
    });
  });
  startBtn.addEventListener('click',()=>beginFromCountdown());
  goRestart.addEventListener('click',()=>{ hideGo(); beginFromCountdown(); });
  goChange.addEventListener('click',()=>{ hideGo(); openSelect(); });
  goQuit.addEventListener('click',()=>location.reload());

  /* ====== Flow ====== */
  function openSelect(){ state='select'; charSel.style.display='flex'; }
  function closeSelect(){ charSel.style.display='none'; }
  function boot(){ state='op'; showCut('op.png',2000); setTimeout(openSelect,2000); }

  function beginFromCountdown(){
    closeSelect();
    scrollX=0; meters=0; speed=baseSpeed; boostGauge=100; boosting=0; enFree=0; invincible=0; wingTime=0;
    coins=0; sparkleT=0; sparkleFrame=0; items.length=0; obstacles.length=0; fires.length=0; villains.length=0;
    nextVillAtM = 1200 + Math.random()*800; slots[0]=slots[1]=null; refreshSlots();
    player.x=RUNX()|0; player.y=(GY()-player.h)|0; player.vy=0; player.onGround=true; player.jumpsLeft=2; player.tilt=0;

    state='countdown';
    showCountdown(['3','2','1','GO'],700,()=>{ state='play'; });
  }

  function refreshSlots(){
    btnItem1.disabled=!slots[0]; btnItem2.disabled=!slots[1];
    btnItem1.textContent = slots[0]? slots[0].type.toUpperCase() : 'アイテム1';
    btnItem2.textContent = slots[1]? slots[1].type.toUpperCase() : 'アイテム2';
  }
  function showGo(){ goMsg.textContent=`記録 ${Math.floor(meters)}m！`; goModal.style.display='flex'; }
  function hideGo(){ goModal.style.display='none'; }
  function die(){ state='gameover'; showGo(); }

  /* ====== Actions ====== */
  function jump(){
    if(state!=='play') return;
    const maxJ=(wingTime>0)?4:2;
    if(player.onGround){ player.vy=-400; player.onGround=false; player.jumpsLeft=maxJ-1; }
    else if(player.jumpsLeft>0){ player.vy=-380; player.jumpsLeft--; }
    elJump.textContent='×' + (player.onGround?maxJ:player.jumpsLeft);
  }
  function boost(){
    if(state!=='play') return;
    if(enFree>0){ boosting=2.5; return; }
    if(boostGauge>=boostMax){ boosting=2.5; boostGauge=0; elBoost.classList.remove('ready'); }
  }
  function useSlot(i){
    const it=slots[i]; if(!it) return;
    if(it.type==='tsubasa') wingTime=5.0;
    if(it.type==='en') enFree=5.0;
    if(it.type==='jump'){
      let near=null, dmin=1e9;
      for(const o of obstacles){
        const deadly = o.deadly || o.deadlySide;
        const d = o.x - scrollX - RUNX();
        if(deadly && d>0 && d<dmin){ dmin=d; near=o; }
      }
      if(near){ near.kind='jumpdai'; near.w=SIZE.jump.w; near.h=SIZE.jump.h; near.y=(GY()-SIZE.jump.h)|0; near.deadly=false; near.deadlySide=false; near.kicked=false; near.backTimer=4.0; }
    }
    slots[i]=null; refreshSlots();
  }

  /* ====== Loop ====== */
  let last=0, dispSp=0, dispT=0;
  function tick(ts){
    if(!last) last=ts;
    let dt=(ts-last)/1000; last=ts; dt=Math.min(dt,1/30);

    if(state==='play'){
      const mult=(boosting>0)?1.6:1;
      const spd=speed*mult;
      scrollX += spd*dt;
      meters   = scrollX/30;

      if(enFree<=0){ boostGauge = Math.min(boostMax, boostGauge + dt*22); if(boostGauge>=boostMax) elBoost.classList.add('ready'); }
      if(boosting>0) boosting-=dt;
      if(enFree>0)   enFree-=dt;
      if(invincible>0) invincible-=dt;
      if(wingTime>0){ wingTime-=dt; if(wingTime<=0 && !player.onGround) player.jumpsLeft=0; }

      spawnRandom(); spawnCollectibles(); maybeVillain();

      // obstacles updates
      const gy=GY()|0;
      for(const o of obstacles){
        if(o.kind==='dokan'){
          o.phase = (o.phase + dt) % 4; // 1s rise,2s stop,1s fall
          let t=o.phase;
          let h = (t<1)? Math.round(30 + t*(SIZE.dokan.h-30)) : (t<3)? SIZE.dokan.h : Math.round(SIZE.dokan.h - (t-3)*(SIZE.dokan.h-30));
          o.h=h|0; o.y=(gy-h)|0; o.w=SIZE.dokan.w;
        }
        if(o.kind==='gomi'){ o.t += dt*2; o.y = (gy-SIZE.gomi.h + Math.sin(o.t)*4)|0; o.x = (o.x + Math.sin(o.t*0.7)*0.18)|0; }
        if(o.kind==='tora'){ if(o.cool>0) o.cool-=dt; }
        if(o.backTimer){ o.backTimer-=dt; if(o.backTimer<=0){ Object.assign(o,{kind:'corn',w:SIZE.corn.w,h:SIZE.corn.h,y:(gy-SIZE.corn.h)|0,deadly:true,deadlySide:false,backTimer:0}); } }
      }
      // cleanup old
      while(obstacles.length && obstacles[0].x < scrollX-360) obstacles.shift();
      for(const f of fires){
        if(!f.landed){ f.vy+=f.ay*dt; f.x+=f.vx*dt; f.y+=f.vy*dt; if(f.y+f.h>=gy-1){ f.y=gy-f.h; f.vx=0; f.vy=0; f.landed=true; } }
      }
      while(fires.length && fires[0].x < scrollX-360) fires.shift();

      updateVill(dt);

      // physics
      player.vy += 900*dt; player.y = (player.y + player.vy*dt)|0;

      // --------- ride & slope snap ----------
      const groundTop = (gy - player.h)|0;
      let targetTop = groundTop;
      let onSlope = false;

      // slope (jumpdai)
      for(const o of obstacles){
        if(o.kind!=='jumpdai') continue;
        const sx = (o.x - scrollX)|0;
        const half = RUNX()+player.w*0.5;
        if(half >= sx && half <= sx + o.w){
          const p = clamp((half - sx)/o.w, 0, 1); // 0..1
          const topY = (gy - p*o.h)|0;           // 斜面上面の足元
          const snapY = (topY - player.h)|0;
          if(player.vy>=-20 || player.y>=snapY-6){
            targetTop = Math.min(targetTop, snapY);
            onSlope = true;
            player.tilt = clamp((p-0.3)*0.6, -0.15, 0.22);
            if(!o.kicked && p>0.6){ o.kicked=true; player.vy=-460; speed += 24; }
          }
        }
      }
      // rideables
      for(const o of obstacles){
        if(o.kind!=='contena' && o.kind!=='tora' && o.kind!=='dokan') continue;
        const sx = (o.x - scrollX)|0;
        const left = sx, right = sx + o.w;
        const center = RUNX()+player.w*0.5;
        if(center < left || center > right) continue;
        const top = o.y|0, feet=player.y+player.h;
        if(feet > top-12 && feet < top+14 && player.vy>=0){
          targetTop = Math.min(targetTop, (top - player.h)|0);
          if(o.kind==='tora' && o.cool<=0){ player.vy=-560; o.cool=.5; }
        }
      }
      if(player.y>=targetTop){ player.y=targetTop; player.vy=0; if(!player.onGround){ player.onGround=true; player.jumpsLeft=(wingTime>0?4:2); } }
      else { player.onGround=false; if(!onSlope) player.tilt*=0.9; }

      // collisions（致死）
      if(invincible<=0){
        for(const f of fires){
          const rx=f.x - scrollX;
          if(rects({x:RUNX(),y:player.y,w:player.w,h:player.h},{x:rx,y:f.y,w:f.w,h:f.h})){ die(); break; }
        }
        for(const o of obstacles){
          const rx=o.x - scrollX;
          const a={x:RUNX(),y:player.y,w:player.w,h:player.h};
          const b={x:rx,y:o.y,w:o.w,h:o.h};
          if(rects(a,b)){
            if(o.kind==='contena'){ const feet=player.y+player.h; if(!(feet<=o.y+4)) { die(); break; } }
            else if(o.kind==='tora'){ const feet=player.y+player.h; if(!(feet<=o.y+6)) { die(); break; } }
            else if(o.kind==='dokan'){ const feet=player.y+player.h; if(!(feet<=o.y+12)) { die(); break; } }
            else if(o.kind==='jumpdai' || o.kind==='kanban'){ /* safe */ }
            else { die(); break; }
          }
        }
      }

      // pickups
      for(let i=items.length-1;i>=0;i--){
        const it=items[i];
        if(it.type!=='coin'){ it.t = (it.t||0) + dt*1.6; it.y = (it.y + Math.sin(it.t)*0.4)|0; }
        const rx=it.x - scrollX;
        if(rects({x:RUNX(),y:player.y,w:player.w,h:player.h},{x:rx,y:it.y,w:it.w,h:it.h})){
          if(it.type==='coin'){ coins++; sparkleT=0; if(coins>=needCoin){ coins=0; invincible=5.0; showCut('mutekiop.png',2000); } }
          else{ if(!(slots[0]&&slots[1])){ if(!slots[0]) slots[0]={type:it.type}; else slots[1]={type:it.type}; refreshSlots(); } }
          items.splice(i,1);
        } else if(rx<-120){ items.splice(i,1); }
      }

      // HUD
      elDist.textContent = `${Math.floor(meters)} m`;
      dispT+=dt; if(dispT>=.2){ dispSp=Math.round(spd*KMH_PER_PX); dispT=0; }
      elSpeed.textContent = `${dispSp} km/h`;
      elJump.textContent  = '×' + (player.onGround?(wingTime>0?4:2):player.jumpsLeft);
      elBoostFill.style.height = `${(boostGauge/boostMax)*100}%`;
      elCoin.textContent = `${coins}/${needCoin}`;
      if(invincible>0){ sparkleT+=dt*8; if(sparkleT>1){ sparkleT=0; sparkleFrame^=1; } }
    }

    draw(); requestAnimationFrame(tick);
  }

  /* ====== Draw ====== */
  function draw(){
    ctx.clearRect(0,0,vw,vh);
    const gy=GY()|0;

    // 背景タイル：Sky
    tileX(IMG['sora.PNG'],    0, vh, 0.25);

    // 草帯（上）: hatake2 固定高さ
    const topH = Math.round(vh*0.20);                 // 草の帯
    const topY = (gy - topH - 120)|0;                 // 見た目合わせ（雲とのバランス）
    tileX(IMG['hatake2.png'], topY, topH, 0.6, 1);

    // 中帯：hatake を地面直前まで（GY ちょうどに終端）
    const midH = (gy - topY)|0;
    tileX(IMG['hatake.png'],  (gy - midH)|0, midH, 0.9, 1);

    // シーム帯：GY直上を do-ro で薄く覆い、下帯と密着（1pxオーバーラップ）
    const seamH = 14; // 必要に応じて自動で上書きされるが、まずは14px
    tileX(IMG['do-ro.png'], (gy - seamH)|0, seamH, 1.0, 1);

    // 下帯（足元～下端）は do-ro で完全タイル（+1px 重ねで線消し）
    const botH = (vh - gy + 1)|0;
    tileX(IMG['do-ro.png'], gy|0, botH, 1.0, 1);

    // 障害物
    for(const o of obstacles){
      const sx=o.x - scrollX; if(sx<-400||sx>vw+400) continue;
      const draw=(name,def)=>{ const im=IMG[name]; if(im&&im.width) ctx.drawImage(im, sx|0, o.y|0, o.w|0, o.h|0); else {ctx.fillStyle=def; ctx.fillRect(sx|0,o.y|0,o.w|0,o.h|0);} };
      if(o.kind==='corn')    draw('corn.PNG','#f7b500');
      else if(o.kind==='gomi')    draw('gomi.png','#9aa');
      else if(o.kind==='contena') draw('contena.png','#597');
      else if(o.kind==='tora')    draw('tora.png','#946');
      else if(o.kind==='dokan')   draw('dokan.png','#2a5');
      else if(o.kind==='jumpdai') draw('jumpdai.png','#58a');
      else if(o.kind==='kanban'){ const im=IMG[o.img]; if(im&&im.width) ctx.drawImage(im,sx|0,o.y|0,o.w|0,o.h|0); else {ctx.fillStyle='#777';ctx.fillRect(sx|0,o.y|0,o.w|0,o.h|0);} }
    }

    // アイテム（障害物の上・プレイヤーの下に表示）
    for(const it of items){
      const sx=it.x - scrollX; if(sx<-200||sx>vw+200) continue;
      let name = it.type==='coin' ? 'coin.png' : (it.type==='tsubasa' ? 'tsubasa.png' : (it.type==='en' ? 'en.png' : 'jump.png'));
      const im=IMG[name]; if(im&&im.width) ctx.drawImage(im, sx|0, it.y|0, it.w|0, it.h|0);
      else { ctx.fillStyle='#7cf'; ctx.fillRect(sx|0,it.y|0,it.w|0,it.h|0); }
    }

    // 火の玉
    for(const f of fires){
      const sx=f.x - scrollX; if(sx<-200||sx>vw+200) continue;
      const im=IMG['tama.png']; if(im&&im.width) ctx.drawImage(im,sx|0,f.y|0,f.w|0,f.h|0); else {ctx.fillStyle='#d33';ctx.fillRect(sx|0,f.y|0,f.w|0,f.h|0);}
    }

    // ヴィラン
    for(const v of villains){
      const sx=v.x - scrollX; const im=IMG['viran.png'];
      if(im&&im.width) ctx.drawImage(im, (sx-60)|0, (v.y-50)|0, 120, 100); else {ctx.fillStyle='#933'; ctx.fillRect((sx-40)|0,(v.y-30)|0,80,60);}
    }

    // プレイヤー（最後）
    ctx.save();
    ctx.translate((RUNX()+player.w/2)|0, (player.y+player.h/2)|0);
    ctx.rotate(player.tilt); ctx.translate((-player.w/2)|0,(-player.h/2)|0);
    const body = (invincible>0)? 'gold.png' : player.sprite;
    const im=IMG[body];
    if(im&&im.width){ ctx.drawImage(im,0,0,player.w|0,player.h|0);
      if(invincible>0){ const sp=IMG[sparkleFrame?'hoshi1.png':'hoshi2.png']; if(sp&&sp.width) ctx.drawImage(sp,-6,-6,(player.w+12)|0,(player.h+12)|0); }
    } else { ctx.fillStyle='#0bf'; ctx.fillRect(0,0,player.w|0,player.h|0); }
    ctx.restore();
  }

  /* ====== Start ====== */
  requestAnimationFrame(tick); // start loop
})();
</script>
</body>
</html>
