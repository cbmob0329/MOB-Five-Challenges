<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1, user-scalable=no">
<title>MOB KART CHALLENGE — v6.0 Rescue（入力/リスタート 安定版）</title>
<style>
  :root{ --ui-fg:#fff; --ui-dim:#9fb0ce; --line:#2b3342;
         --safe-top: env(safe-area-inset-top,0px); --safe-bottom: env(safe-area-inset-bottom,0px); }
  html,body{margin:0;height:100%;background:#000;color:var(--ui-fg);font-family:-apple-system,system-ui,Segoe UI,Roboto,"Hiragino Sans","Yu Gothic",sans-serif;
    -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;}
  *{box-sizing:border-box}
  #app{position:fixed;inset:0;overflow:hidden}

  /* 固定UI */
  .topbar{position:fixed;inset:0 0 auto 0;z-index:300;display:flex;gap:12px;align-items:center;
    padding:calc(8px + var(--safe-top)) 12px 8px;background:rgba(11,15,20,.9);backdrop-filter:blur(8px)}
  .title b{font-size:16px}.title small{display:block;color:var(--ui-dim);font-size:11px}
  .right{margin-left:auto}
  .ghost{background:#0f141b;border:1px solid var(--line);color:#dfe7f7;border-radius:14px;padding:8px 12px;font-size:13px}

  .hud{position:fixed;top:calc(48px + var(--safe-top));left:0;right:0;z-index:260;display:flex;gap:10px;align-items:center;padding:8px 12px;pointer-events:none}
  .pill{pointer-events:auto;min-width:72px;padding:8px 12px;border-radius:18px;background:#182028;border:1px solid var(--line)}
  .pill h6{margin:0;font-size:10px;color:var(--ui-dim)} .pill .v{font-size:14px;margin-top:2px}

  .boostrow{position:fixed;left:12px;right:12px;top:calc(128px + var(--safe-top));z-index:250}
  .boostbar{height:18px;border-radius:10px;border:1px solid var(--line);background:#0c1118;overflow:hidden;box-shadow:0 6px 18px rgba(0,0,0,.35)}
  .boostbar .fill{height:100%;width:0;background:linear-gradient(90deg,#1fb6ff,#60a5fa)}
  .boostbar.ready{box-shadow:0 0 0 2px rgba(31,182,255,.18), inset 0 0 14px rgba(96,165,250,.45)}

  #stageWrap{position:fixed;inset:0;z-index:50}
  #cv{width:100%;height:100%;display:block;background:#000;touch-action:none}

  .controls{position:fixed;left:0;right:0;bottom:0;z-index:320;display:grid;grid-template-columns:1fr 1fr 1fr 1fr;gap:10px;
    padding:10px 12px calc(10px + var(--safe-bottom));pointer-events:auto}
  .cbtn{border-radius:16px;padding:14px 10px;border:1px solid var(--line);background:#0e1218;box-shadow:0 8px 24px rgba(0,0,0,.35);color:#dfe7f7;font-size:15px}
  .cbtn:active{transform:translateY(1px)} .jump{background:#0f1523} .boost{background:#1a0f12} .item{background:#0f171a}
  .cbtn[disabled]{opacity:.35}

  .cut{position:fixed;inset:0;z-index:200;display:flex;align-items:center;justify-content:center;pointer-events:none}
  .cut img{max-width:70vw;max-height:60vh;filter:drop-shadow(0 10px 24px rgba(0,0,0,.55));opacity:0;transform:scale(.95);transition:.25s}
  .cut.show img{opacity:1;transform:scale(1)}
  .countdown{position:fixed;inset:0;z-index:210;display:flex;align-items:center;justify-content:center;font-weight:800;font-size:64px;letter-spacing:2px;text-shadow:0 8px 30px rgba(0,0,0,.6);opacity:0;transition:.15s;pointer-events:none}
  .countdown.show{opacity:1}

  .centerModal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:400;pointer-events:auto}
  .centerModal.show{display:flex}
  .card{background:#0b0f15;border:1px solid #253044;border-radius:16px;padding:16px;min-width:260px;box-shadow:0 12px 36px rgba(0,0,0,.5)}
  .row{display:flex;gap:10px;align-items:center;justify-content:center}
  .opt{border:1px solid var(--line);background:#0d121a;border-radius:12px;padding:8px 10px}
  .opt img{height:64px}
  .stack{display:flex;gap:10px;justify-content:center;margin-top:10px}

  #fatal{position:fixed;inset:0;z-index:9999;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6)}
  #fatal .msg{background:#180d0d;border:1px solid #4a2323;color:#ffdede;border-radius:12px;padding:12px;max-width:90vw;font:12px/1.5 ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap}
</style>
</head>
<body>
<div id="app">
  <div class="topbar">
    <div class="title"><b>MOB KART CHALLENGE</b><small>v6.0</small></div>
    <div class="right"><button id="btnFS" class="ghost">全画面</button></div>
  </div>

  <div class="hud">
    <div class="pill"><h6>距離</h6><div class="v" id="hudDist">0 m</div></div>
    <div class="pill"><h6>速度</h6><div class="v" id="hudSpeed">0 km/h</div></div>
    <div class="pill"><h6>ジャンプ</h6><div class="v" id="hudJump">×2</div></div>
    <div class="pill" id="hudCoin"><h6>コイン</h6><div class="v">0/10</div></div>
    <div class="pill"><h6>キャラ</h6><div class="v"><button id="btnChange" class="ghost">変更</button></div></div>
  </div>
  <div class="boostrow"><div class="boostbar" id="boostBar"><div class="fill"></div></div></div>

  <div id="stageWrap"><canvas id="cv" width="540" height="960"></canvas></div>

  <div class="controls">
    <button id="btnJump"  class="cbtn jump">ジャンプ</button>
    <button id="btnBoost" class="cbtn boost">ブースト</button>
    <button id="btnItem1" class="cbtn item" disabled>アイテム1</button>
    <button id="btnItem2" class="cbtn item" disabled>アイテム2</button>
  </div>

  <div class="cut" id="cut"><img id="cutImg" alt=""></div>
  <div class="countdown" id="countdown">3</div>

  <div class="centerModal" id="charSel">
    <div class="card">
      <div style="font-size:20px;font-weight:700;margin-bottom:8px">キャラ選択</div>
      <div class="row">
        <button class="opt" id="pickOrange"><img src="orange.png" alt="orange"></button>
        <button class="opt" id="pickVR"><img src="VR.png" alt="VR"></button>
      </div>
      <div class="stack"><button id="btnStart" class="cbtn" style="font-size:18px;padding:14px 28px">スタート</button></div>
    </div>
  </div>

  <div class="centerModal" id="gameOver">
    <div class="card">
      <div id="goMsg" style="font-size:22px;font-weight:700;margin-bottom:10px">記録 0m！</div>
      <div class="stack">
        <button id="goRestart" class="cbtn">リスタート</button>
        <button id="goChange"  class="cbtn">キャラ選択へ</button>
        <button id="goQuit"    class="cbtn">やめる</button>
      </div>
    </div>
  </div>

  <div id="fatal"><div class="msg" id="fatalMsg"></div></div>
</div>

<script>
(() => {
/* ========= 簡易タップ束ね（ボタン用）：pointerdown + touchstart + click ========= */
function bindTap(el, handler){
  let gate=0;
  function wrap(ev){ ev&&ev.preventDefault&&ev.preventDefault(); const now=performance.now(); if(now-gate<100) return; gate=now; handler(); }
  el.addEventListener('pointerdown',wrap,{passive:false});
  el.addEventListener('touchstart',wrap,{passive:false});
  el.addEventListener('click',wrap,{passive:false});
}

/* ===== Canvas ===== */
const cv=document.getElementById('cv'); const ctx=cv.getContext('2d'); ctx.imageSmoothingEnabled=false;
let vw=cv.width|0, vh=cv.height|0;
function safeViewport(){
  let w=(innerWidth||document.documentElement.clientWidth||540);
  let h=(innerHeight||document.documentElement.clientHeight||960);
  if(!h || h<200){ h=(screen&&screen.height)||960; }
  w=Math.max(540,Math.min(720,Math.round(w)));
  h=Math.max(900,Math.min(1200,Math.round(h)));
  return [w,h];
}
function fit(){ const [w,h]=safeViewport(); vw=cv.width=w; vh=cv.height=h; }
addEventListener('resize',fit,{passive:true}); addEventListener('orientationchange',fit,{passive:true}); addEventListener('pageshow',fit,{passive:true}); fit();

/* ===== DOM refs ===== */
const elDist=document.getElementById('hudDist'), elSpeed=document.getElementById('hudSpeed'),
      elJump=document.getElementById('hudJump'), elCoin=document.getElementById('hudCoin').querySelector('.v'),
      cut=document.getElementById('cut'), cutImg=document.getElementById('cutImg'), countdown=document.getElementById('countdown'),
      boostBar=document.getElementById('boostBar'), boostFill=boostBar.querySelector('.fill'),
      charSel=document.getElementById('charSel'), btnStart=document.getElementById('btnStart'),
      btnChange=document.getElementById('btnChange'), pickOrange=document.getElementById('pickOrange'), pickVR=document.getElementById('pickVR'),
      goModal=document.getElementById('gameOver'), goMsg=document.getElementById('goMsg'),
      fatal=document.getElementById('fatal'), fatalMsg=document.getElementById('fatalMsg');

const btnFS=document.getElementById('btnFS'), btnJump=document.getElementById('btnJump'), btnBoost=document.getElementById('btnBoost'),
      btnItem1=document.getElementById('btnItem1'), btnItem2=document.getElementById('btnItem2'),
      goRestart=document.getElementById('goRestart'), goChange=document.getElementById('goChange'), goQuit=document.getElementById('goQuit');

/* ===== Utils ===== */
const shrink=(r,p)=>({x:r.x+p,y:r.y+p,w:r.w-2*p,h:r.h-2*p});
const rects=(a,b)=>!(a.x+a.w<b.x||b.x+b.w<a.x||a.y+a.h<b.y||b.y+b.h<a.y);
function showFatal(e){ fatalMsg.textContent=String(e&&e.stack||e); fatal.style.display='flex'; }
function toggleFS(){ const el=document.documentElement;
  if(!document.fullscreenElement && !document.webkitFullscreenElement){ (el.requestFullscreen||el.webkitRequestFullscreen).call(el); btnFS.textContent='全画面解除'; }
  else{ (document.exitFullscreen||document.webkitExitFullscreen).call(document); btnFS.textContent='全画面'; }}

/* ===== Assets ===== */
const essential=['sora.PNG','hatake2.png','do-ro.png','mob.png','orange.png','VR.png','op.png','jumpdai.png','contena.png','tora.png','dokan.png'];
const deferred=['corn.PNG','kanban1.png','kanban2.png','kanban3.png','kanban4.png','kanban5.png','kanban6.png','coin.png','gold.png','hoshi1.png','hoshi2.png','mutekiop.png','viran op.png','viran.png','tama.png','tsubasa.png','jump.png','en.png','gomi.png'];
const IMG={}; function loadList(list){ for(const fn of list){ const im=new Image(); im.src=encodeURI(fn); im.onload=()=>{IMG[fn]=im; analyzeTop(fn,im)}; im.onerror=()=>{IMG[fn]=im}; } }
loadList(essential);

/* ===== Ride top auto detect ===== */
const rideSrcKind={'contena.png':'contena','tora.png':'tora','dokan.png':'dokan'};
const DEFAULT_RIDE_PX={contena:14,tora:10,dokan:12};
const RIDE_TWEAK_PX={contena:1,tora:1,dokan:3};
const rideFrac={};
function analyzeTop(src,img){
  const kind=rideSrcKind[src]; if(!kind) return;
  try{
    const w=img.naturalWidth||img.width, h=img.naturalHeight||img.height; if(!w||!h) return;
    const c=document.createElement('canvas'); c.width=w; c.height=h; const g=c.getContext('2d'); g.drawImage(img,0,0);
    const data=g.getImageData(0,0,w,h).data;
    const xmin=Math.floor(w*0.15), xmax=Math.ceil(w*0.85), step=Math.max(1,Math.floor((xmax-xmin)/24));
    let top=h;
    for(let x=xmin;x<=xmax;x+=step){ for(let y=0;y<h;y++){ if(data[(y*w+x)*4+3]>16){ if(y<top) top=y; break; } } }
    if(top!==h) rideFrac[kind]=top/h;
  }catch(e){}
}
const rideInsetPx=(kind,scaledH)=> {
  const base = rideFrac.hasOwnProperty(kind)?Math.round(scaledH*rideFrac[kind]):(DEFAULT_RIDE_PX[kind]||2);
  return base + (RIDE_TWEAK_PX[kind]||0);
};

/* ===== World ===== */
const GY=()=>Math.floor(vh*0.80), RUNX=()=>Math.floor(vw*0.25);
const SAFE_M=80, PX_PER_M=30, KMH_PER_PX=0.12;

const SIZE={
  player:{w:90,h:64}, corn:{w:54,h:76}, gomi:{w:110,h:102},
  cont:{w:172,h:158}, tora:{w:176,h:122}, dokan:{w:126,hMax:110},
  jump:{w:240,h:78}, kanban:{w:540,h:405}, coin:{w:26,h:26}, item:{w:34,h:34}
};

let state='boot', scrollX=0, meters=0;
let baseSpeed=333, boostGauge=0, boostMax=100, boosting=0, enFree=0, invincible=0, wingTime=0;
let coins=0, needCoin=10, sparkleT=0, sparkleFrame=0, nextVillAtM=1200+Math.random()*800;

const player={sprite:'orange.png', w:SIZE.player.w, h:SIZE.player.h, x:RUNX()|0, y:(GY()-SIZE.player.h)|0, vy:0, onGround:true, jumpsLeft:2, tilt:0, prevFeet:0};

const items=[], obstacles=[], fires=[], villains=[]; const slots=[null,null];

/* ===== OP & Select ===== */
const showCut=(fn,ms=2000)=>{ cutImg.src=encodeURI(fn); cut.classList.add('show'); setTimeout(()=>cut.classList.remove('show'),ms); };
let goTimer=null; // 自動復帰
function openSelect(){ if(state==='countdown'||state==='play') return; charSel.classList.add('show'); state='select'; }
function closeSelect(){ charSel.classList.remove('show'); }
function goToSelect(){ if(goTimer){ clearTimeout(goTimer); goTimer=null; } goModal.classList.remove('show'); openSelect(); }

function bootFlow(){
  state='op'; showCut('op.png',2000);
  setTimeout(openSelect,2200);
  setTimeout(()=>{ if(state!=='play'&&state!=='countdown'&&state!=='select'){ openSelect(); } },3500);
}

/* ===== 入力（Canvasタップでジャンプ） ===== */
cv.addEventListener('pointerdown', e=>{ const h=(innerHeight||document.documentElement.clientHeight||0); if(!h || e.clientY<h*0.75) pressJump(); }, {passive:false});
cv.addEventListener('touchstart', e=>{ const t=e.touches&&e.touches[0]; const h=(innerHeight||document.documentElement.clientHeight||0); if(!h || (t?t.clientY:0)<h*0.75) pressJump(); }, {passive:false});
cv.addEventListener('click', e=>{ const h=(innerHeight||document.documentElement.clientHeight||0); if(!h || e.clientY<h*0.75) pressJump(); }, {passive:false});

/* ===== カウントダウン ===== */
let cdActive=false, cdStart=0, cdShown=-1;
function hardResetCountdown(){ cdActive=false; cdShown=-1; countdown.classList.remove('show'); }
function beginCountdown(){ cdActive=true; cdStart=performance.now(); cdShown=-1; countdown.classList.add('show'); }
function driveCountdown(now){
  if(!cdActive) return;
  const t=(now-cdStart)/1000;
  const step=t<0.7?0:t<1.4?1:t<2.1?2:t<2.8?3:4;
  if(step!==cdShown){ countdown.textContent=['3','2','1','GO',''][step]||''; cdShown=step; }
  if(step>=4){ countdown.classList.remove('show'); cdActive=false; state='play'; }
}

/* ===== Flow ===== */
let lastRightX=0, nextSpawnX=null, lastKanbanX=-1e9;
const MIN_GAP_PX=40;

let startLock=false;
function startFlow(){
  if(startLock) return; startLock=true;
  if(goTimer){ clearTimeout(goTimer); goTimer=null; }
  closeSelect(); hardResetCountdown();
  resetWorld(); draw();
  requestAnimationFrame(()=>{ state='countdown'; beginCountdown(); startLock=false; });
  setTimeout(()=>loadList(deferred),300);
}
function restartFlow(){
  if(goTimer){ clearTimeout(goTimer); goTimer=null; }
  goModal.classList.remove('show');
  hardResetCountdown(); resetWorld(); draw();
  requestAnimationFrame(()=>{ state='countdown'; beginCountdown(); });
}

function resetWorld(){
  scrollX=0; meters=0; boostGauge=0; boosting=0; enFree=0; invincible=0; wingTime=0;
  coins=0; sparkleT=0; sparkleFrame=0; items.length=0; obstacles.length=0; fires.length=0; villains.length=0;
  slots[0]=slots[1]=null; refreshSlots(); nextVillAtM=1200+Math.random()*800;
  player.x=RUNX()|0; player.y=(GY()-player.h)|0; player.vy=0; player.onGround=true; player.jumpsLeft=2; player.tilt=0; player.prevFeet=player.y+player.h;
  boostBar.classList.remove('ready');
  lastRightX=SAFE_M*PX_PER_M; nextSpawnX=null; lastKanbanX=-1e9;
  placeEarlyContena(); scheduleNextSpawn();
  wantBoost=false; wantUse=[false,false]; last=0;
  coyote=0; jumpBuf=0; jumpLock=0;
}

/* ===== Buttons bind ===== */
bindTap(btnFS, ()=>toggleFS());
bindTap(btnChange, ()=>openSelect());
bindTap(btnStart, ()=>startFlow());
bindTap(pickOrange, ()=>player.sprite='orange.png');
bindTap(pickVR, ()=>player.sprite='VR.png');

bindTap(btnJump, ()=>pressJump());
bindTap(btnBoost, ()=>{ wantBoost=true; });
bindTap(btnItem1, ()=>useSlot(0));
bindTap(btnItem2, ()=>useSlot(1));

bindTap(goRestart, ()=>restartFlow());
bindTap(goChange,  ()=>goToSelect());
bindTap(goQuit,    ()=>location.reload());

/* ===== Input states ===== */
let wantBoost=false,wantUse=[false,false];
const COYOTE_DUR=0.12, JUMPBUF_DUR=0.18;
let coyote=0, jumpBuf=0, jumpLock=0;
function pressJump(){ jumpBuf=JUMPBUF_DUR; }
addEventListener('keydown',e=>{ if(e.code==='Space'||e.code==='ArrowUp') pressJump(); if(e.code==='ShiftRight') wantBoost=true; },{passive:true});

/* ===== Spawner / Items ほか（既存と同等） ===== */
function scheduleNextSpawn(){ const gapM=6+Math.random()*8; nextSpawnX = lastRightX + gapM*PX_PER_M; }
const ensureGap=x=> (x<lastRightX+MIN_GAP_PX)?(lastRightX+MIN_GAP_PX):x;

function spawnAt(kind,x){
  const gy=GY()|0, ground=h=>(gy-h)|0; let placedRight=lastRightX;
  if(kind==='contena'){ x=ensureGap(x); const n=(Math.random()<.55?2:3);
    for(let i=0;i<n;i++){ const ox=x+i*(172+10); obstacles.push({kind:'contena',x:ox|0,y:ground(158),w:172,h:158,deadlySide:true}); placedRight=ox+172; } }
  else if(kind==='corn'){ x=ensureGap(x); obstacles.push({kind:'corn',x:x|0,y:ground(76),w:54,h:76,deadly:true}); placedRight=x+54; }
  else if(kind==='gomi'){ x=ensureGap(x); obstacles.push({kind:'gomi',x:x|0,y:ground(102),w:110,h:102,deadly:true,t:Math.random()*6}); placedRight=x+110; }
  else if(kind==='tora'){ x=ensureGap(x); obstacles.push({kind:'tora',x:x|0,y:ground(122),w:176,h:122,deadlySide:true,cool:0}); placedRight=x+176; }
  else if(kind==='dokan'){ x=ensureGap(x); obstacles.push({kind:'dokan',x:x|0,baseY:gy,phase:0,y:ground(28),w:126,h:28,deadlySide:true}); placedRight=x+126; }
  else if(kind==='jumpdai'){ x=ensureGap(x); obstacles.push({kind:'jumpdai',x:x|0,y:ground(78),w:240,h:78,kicked:false,pLast:0}); placedRight=x+240; }
  else if(kind==='kanban'){ if(x-lastKanbanX<1400) return; x=ensureGap(x); const k=1+Math.floor(Math.random()*6);
    obstacles.push({kind:'kanban',img:'kanban'+k+'.png',x:x|0,y:ground(405),w:540,h:405}); lastKanbanX=x; placedRight=x+540; }
  if(placedRight>lastRightX) lastRightX=placedRight;
}
function pickKind(){ const pool=[['corn',3],['gomi',3],['contena',3.5],['tora',2.2],['dokan',2.2],['jumpdai',2],['kanban',0.08]];
  let sum=0; for(const p of pool) sum+=p[1]; let r=Math.random()*sum; for(const p of pool){ r-=p[1]; if(r<=0) return p[0]; } return 'corn'; }
function placeEarlyContena(){
  let base=SAFE_M*PX_PER_M + 8*PX_PER_M;
  let x=Math.max(lastRightX+MIN_GAP_PX, base + ((Math.random()*6|0)*PX_PER_M));
  const sets=4+(Math.random()*3|0);
  for(let s=0;s<sets;s++){ spawnAt('contena',x); if(Math.random()<0.4) spawnAt('jumpdai', lastRightX+80); x=lastRightX+(8+Math.random()*8)*PX_PER_M; }
}

/* アイテム */
function useSlot(i){
  const it=slots[i]; if(!it) return;
  if(it.type==='tsubasa') wingTime=5.0;
  if(it.type==='en') enFree=5.0;
  if(it.type==='jump'){
    let near=null, dmin=1e9;
    for(const o of obstacles){ const deadly=(o.deadly||o.deadlySide), d=o.x - scrollX - RUNX(); if(deadly && d>0 && d<dmin){ dmin=d; near=o; } }
    if(near){ Object.assign(near,{kind:'jumpdai',w:240,h:78,y:(GY()-78)|0,deadly:false,deadlySide:false,kicked:false,pLast:0,backTimer:4.0}); }
  }
  slots[i]=null; refreshSlots();
}
function refreshSlots(){ btnItem1.disabled=!slots[0]; btnItem2.disabled=!slots[1];
  btnItem1.textContent=slots[0]?String(slots[0].type).toUpperCase():'アイテム1';
  btnItem2.textContent=slots[1]?String(slots[1].type).toUpperCase():'アイテム2'; }

/* Collectibles（レア） */
let lastCoinAtM=-9999, lastRareAtM=-9999;
function spawnCollectibles(){
  const gy=GY()|0;
  if(!items.some(it=>it.type==='coin') && Math.random()<0.0012 && meters-lastCoinAtM>900){
    const n=(Math.random()<.5?3:5), start=scrollX+vw+180+Math.random()*260, baseY=gy-(80+Math.random()*50);
    for(let i=0;i<n;i++) items.push({type:'coin',x:(start+i*32)|0,y:(baseY+Math.sin(i)*6)|0,w:26,h:26});
    lastCoinAtM=meters;
  }
  if(!items.some(it=>it.type!=='coin') && Math.random()<0.0018 && meters-lastRareAtM>900){
    const types=['tsubasa','jump','en']; const type=types[Math.floor(Math.random()*3)];
    const y=gy-(60+Math.random()*40);
    items.push({type, x:(scrollX+vw+200+Math.random()*260)|0, y:y|0, w:34,h:34, t:Math.random()*6});
    lastRareAtM=meters;
  }
}

/* ヴィラン */
function maybeVillain(){
  if(meters>=nextVillAtM && villains.length===0){
    showCut('viran op.png',2000);
    setTimeout(()=>{ if(state!=='play') return;
      villains.push({x:scrollX+RUNX()+260, y:-80, vy:20, state:'descend', hoverY:GY()-220, left:5+Math.floor(Math.random()*4), t:1});
    },450);
    nextVillAtM += 1000 + Math.random()*1000;
  }
}
function updateVill(dt){
  for(let i=0;i<villains.length;i++){
    const v=villains[i];
    if(v.state==='descend'){ v.y+=v.vy*dt; if(v.y>=v.hoverY){ v.y=v.hoverY; v.state='hover'; } }
    else if(v.state==='hover'){ const tx=scrollX+RUNX()+260; v.x+=(tx-v.x)*0.03; v.t-=dt; if(v.t<=0){ v.state='throw'; v.t=1.0+Math.random()*1.1; } }
    else if(v.state==='throw'){ const txx=scrollX+RUNX()+80+Math.random()*140; fires.push({x:v.x,y:v.y+18,vx:(txx-v.x)*0.6,vy:40,ay:520,w:42,h:42,landed:false}); v.left--; v.state='hover'; if(v.left<=0) v.state='ascend'; }
    else if(v.state==='ascend'){ v.y-=18*dt*60; if(v.y<-120) v.state='done'; }
  }
  while(villains.length && villains[0].state==='done') villains.shift();
}

/* ===== Game loop ===== */
let last=0, dispSp=0, dispT=0, jumpLock=0;
const GRAVITY=960, MAX_LAND_SPEED=520;
const KMH_PER_PX=0.12, PX_PER_M=30;

function tryConsumeJump(){
  if(jumpBuf<=0 || jumpLock>0) return false;
  const maxJ=(wingTime>0)?4:2;
  const canFirst = player.onGround || coyote>0;
  const canSecond = (!player.onGround && player.jumpsLeft>0);
  if(canFirst){ player.vy=-540; player.onGround=false; player.jumpsLeft=maxJ-1; jumpBuf=0; coyote=0; jumpLock=0.08; return true; }
  if(canSecond){ player.vy=-490; player.jumpsLeft--; jumpBuf=0; jumpLock=0.08; return true; }
  return false;
}

function gameStep(ts){
  try{
    if(!last) last=ts; let dt=(ts-last)/1000; last=ts; if(dt>1/30) dt=1/30;

    if(state==='countdown') driveCountdown(ts);

    if(state==='play'){
      const mult=(boosting>0)?1.7:1, spd=baseSpeed*mult;
      scrollX += spd*dt; meters=scrollX/PX_PER_M;

      if(nextSpawnX && (scrollX+vw+120)>=nextSpawnX){ spawnAt(pickKind(),nextSpawnX|0); scheduleNextSpawn(); }

      if(wantBoost){ if(enFree>0){boosting=2.5;} else if(boostGauge>=boostMax){boosting=2.5; boostGauge=0; boostBar.classList.remove('ready');} wantBoost=false; }

      if(enFree<=0){ boostGauge=Math.min(boostMax,boostGauge+dt*8); if(boostGauge>=boostMax) boostBar.classList.add('ready'); }
      if(boosting>0) boosting-=dt; if(enFree>0) enFree-=dt; if(invincible>0) invincible-=dt;
      if(wingTime>0){ wingTime-=dt; if(wingTime<=0 && !player.onGround) player.jumpsLeft=0; }

      spawnCollectibles(); maybeVillain();

      const gy=GY()|0;

      // animate obstacles
      for(let i=0;i<obstacles.length;i++){
        const o=obstacles[i];
        if(o.kind==='dokan'){
          o.phase=(o.phase+dt)%4; const t=o.phase;
          const h=(t<1)?Math.round(28+t*(110-28)):(t<3)?110:Math.round(110-(t-3)*(110-28));
          o.h=h|0; o.y=(gy-h)|0; o.w=126;
        }else{ o.y=(gy-o.h)|0; }
        if(o.cool) o.cool=Math.max(0,o.cool-dt);
        if(o.backTimer){ o.backTimer-=dt; if(o.backTimer<=0){ Object.assign(o,{kind:'corn',w:54,h:76,y:(gy-76)|0,deadly:true,deadlySide:false,backTimer:0}); } }
      }
      while(obstacles.length && obstacles[0].x<scrollX-520) obstacles.shift();

      for(let i=0;i<fires.length;i++){ const f=fires[i]; if(!f.landed){ f.vy+=520*dt; f.x+=f.vx*dt; f.y+=f.vy*dt; if(f.y+f.h>=gy-1){ f.y=gy-f.h; f.vx=0; f.vy=0; f.landed=true; } } }
      while(fires.length && fires[0].x<scrollX-520) fires.shift();
      updateVill(dt);

      // physics
      player.vy += GRAVITY*dt;
      player.y += player.vy*dt;
      const px=RUNX(), pw=player.w;
      const footW=Math.max(12,Math.round(pw*0.34)), footX=Math.round(px+(pw-footW)/2);
      const foot={x:footX,y:player.y+player.h-1,w:footW,h:2};
      let supportTop=gy, onSlope=false, supportFrom='ground', supportObj=null;

      const feet=player.y+player.h;

      // slope
      for(const o of obstacles){
        if(o.kind!=='jumpdai') continue;
        const sx=o.x-scrollX;
        const pxFront = px + pw*0.60;
        if(pxFront>=sx && pxFront<=sx+o.w){
          const p=(pxFront - sx)/o.w;
          const topY=(gy - p*o.h)|0;
          const touching = (feet>=topY-8 && feet<=topY+22);
          if(touching){
            if(topY<supportTop){ supportTop=topY; supportFrom='jumpdai'; supportObj=o; }
            onSlope=true; player.tilt=Math.max(-0.15,Math.min(0.24,(p-0.3)*0.6));
            if(!o.kicked && (o.pLast||0)<=0.56 && p>0.56){ o.kicked=true; player.vy=-840; boosting=Math.max(boosting,1.3); jumpLock=Math.max(jumpLock,0.15); }
          }
          o.pLast=p;
        } else { o.pLast=0; }
      }

      // rideables
      for(const o of obstacles){
        if(o.kind!=='contena'&&o.kind!=='tora'&&o.kind!=='dokan') continue;
        const sx=o.x-scrollX, rect={x:sx,y:o.y,w:o.w,h:o.h};
        if(rects(foot,rect)){
          const inset=rideInsetPx(o.kind,o.h), topY=o.y+inset;
          if(topY<supportTop){ supportTop=Math.round(topY); supportFrom=o.kind; supportObj=o; }
        }
      }

      // landing
      const targetY = (supportTop - player.h + 1);
      const withinCatch = (feet >= supportTop-22 && feet <= supportTop+22);
      if(withinCatch){
        const dy = targetY - player.y;
        if(dy >= -2){
          const step = Math.min(Math.max(dy,0), MAX_LAND_SPEED*dt);
          player.y += step;
          if(Math.abs(targetY - player.y) <= 1.5){
            player.y = targetY|0;
            if(supportFrom==='tora' && supportObj && (!supportObj.cool||supportObj.cool<=0)){
              player.vy=-760; player.onGround=false; jumpLock=0.12; supportObj.cool=0.25;
            }else{
              player.vy=0; if(!player.onGround){ player.onGround=true; player.jumpsLeft=(wingTime>0?4:2); }
            }
          }else{
            player.vy = Math.min(player.vy, MAX_LAND_SPEED);
            if(!player.onGround){ player.onGround=true; }
          }
        }else{
          player.y = targetY|0; player.vy=0; if(!player.onGround){ player.onGround=true; player.jumpsLeft=(wingTime>0?4:2); }
        }
      }else{
        if(player.onGround && !onSlope){ coyote = COYOTE_DUR; }
        player.onGround=false; if(!onSlope) player.tilt*=0.9;
      }

      // ★ジャンプ先消費
      if(jumpBuf>0 && jumpLock<=0){ tryConsumeJump(); }
      // timers
      if(jumpBuf>0) jumpBuf=Math.max(0,jumpBuf-dt);
      if(coyote>0)  coyote=Math.max(0,coyote-dt);
      if(jumpLock>0)jumpLock=Math.max(0,jumpLock-dt);

      // death
      if(invincible<=0){
        const A=shrink({x:px,y:player.y,w:pw,h:player.h},4);
        for(const ff of fires){ const rx=ff.x-scrollX; if(rects(A,shrink({x:rx,y:ff.y,w:ff.w,h:ff.h},4))){ die(); return; } }
        for(const o of obstacles){
          const rx2=o.x-scrollX, B0={x:rx2,y:o.y,w:o.w,h:o.h};
          if(o.kind==='corn'||o.kind==='gomi'){ if(rects(A,shrink(B0,6))){ die(); return; } }
          else if(o.kind==='contena'||o.kind==='tora'||o.kind==='dokan'){
            const top=o.y+rideInsetPx(o.kind,o.h), B=shrink(B0,4);
            const onTop=(A.y+A.h)<=top+12 && A.x+A.w>B.x && A.x<B.x+B.w;
            if(!onTop && rects(A,B)){ die(); return; }
          }
        }
      }

      // items
      for(let i=items.length-1;i>=0;i--){
        const it=items[i]; if(it.type!=='coin'){ it.t=(it.t||0)+dt*1.6; it.y=(it.y+Math.sin(it.t)*0.4)|0; }
        const irx=it.x-scrollX;
        if(rects(shrink({x:px,y:player.y,w:pw,h:player.h},4),{x:irx,y:it.y,w:it.w,h:it.h})){
          if(it.type==='coin'){ if(++coins>=needCoin){ coins=0; invincible=5.0; showCut('mutekiop.png',2000);} }
          else{ if(!(slots[0]&&slots[1])){ if(!slots[0]) slots[0]={type:it.type}; else slots[1]={type:it.type}; refreshSlots(); } }
          items.splice(i,1);
        } else if(irx<-200) items.splice(i,1);
      }

      // HUD
      elDist.textContent=Math.floor(meters)+' m';
      dispT+=dt; if(dispT>=.2){ const spd=baseSpeed*(boosting>0?1.7:1); dispSp=Math.round(spd*KMH_PER_PX); dispT=0; }
      elSpeed.textContent=dispSp+' km/h';
      elJump.textContent='×'+(player.onGround?(wingTime>0?4:2):player.jumpsLeft);
      boostFill.style.width=(boostGauge/boostMax*100)+'%';
      if(invincible>0){ sparkleT+=dt*8; if(sparkleT>1){ sparkleT=0; sparkleFrame^=1; } }
    }

    draw();
  }catch(e){ console.error(e); showFatal(e); }
  requestAnimationFrame(gameStep);
}
requestAnimationFrame(gameStep);

/* ===== Draw ===== */
function tileX(img,y,h,f=1,over=0){ if(!(img&&img.width)) return; y=(y-over)|0; h=(h+over)|0; const asp=img.width/img.height; const pw=Math.max(16,Math.round(h*asp)); const tx=-((scrollX*f)%pw); for(let x=tx-pw;x<vw+pw;x+=pw) ctx.drawImage(img,x|0,y|0,pw|0,h|0); }
function tileXRef(img,y,h,f,ref,over=0){ if(!(img&&img.width)) return; y=(y-over)|0; h=(h+over)|0; const asp=(ref&&ref.width)?(ref.width/ref.height):(img.width/img.height); const pw=Math.max(16,Math.round(h*asp)); const tx=-((scrollX*f)%pw); for(let x=tx-pw;x<vw+pw;x+=pw) ctx.drawImage(img,x|0,y|0,pw|0,h|0); }

function draw(){
  const sky=ctx.createLinearGradient(0,0,0,vh); sky.addColorStop(0,'#7ec9ff'); sky.addColorStop(1,'#a0defa'); ctx.fillStyle=sky; ctx.fillRect(0,0,vw,vh);
  const gy=GY()|0;
  tileX(IMG['sora.PNG'],0,vh,0.25);
  const grassH=Math.round(vh*0.20), grassTopY=Math.max(0, gy-grassH-Math.round(vh*0.24));
  if(IMG['hatake2.png']) tileX(IMG['hatake2.png'],grassTopY,grassH,0.6,1);
  const seamH=10, bandTop=(grassTopY+grassH)|0, bandH=Math.max(0,(gy-seamH)-bandTop);
  if(IMG['do-ro.png']) tileX(IMG['do-ro.png'],bandTop,bandH,1,1);
  if(IMG['mob.png']){ tileXRef(IMG['mob.png'],(gy-seamH)|0,seamH,1,IMG['do-ro.png'],1); tileXRef(IMG['mob.png'],gy|0,(vh-gy+1)|0,1,IMG['do-ro.png'],1); }

  for(const o of obstacles){
    const sx=o.x-scrollX; if(sx<-520||sx>vw+520) continue;
    let im=null;
    if(o.kind==='corn') im=IMG['corn.PNG']; else if(o.kind==='gomi') im=IMG['gomi.png']; else if(o.kind==='contena') im=IMG['contena.png'];
    else if(o.kind==='tora') im=IMG['tora.png']; else if(o.kind==='dokan') im=IMG['dokan.png']; else if(o.kind==='jumpdai') im=IMG['jumpdai.png'];
    else if(o.kind==='kanban') im=IMG[o.img];
    if(im&&im.width) ctx.drawImage(im,sx|0,o.y|0,o.w|0,o.h|0); else { ctx.fillStyle='#666'; ctx.fillRect(sx|0,o.y|0,o.w|0,o.h|0); }
  }

  for(const it of items){
    const sx=it.x-scrollX; if(sx<-260||sx>vw+260) continue;
    const name=(it.type==='coin')?'coin.png':(it.type==='tsubasa'?'tsubasa.png':(it.type==='en'?'en.png':'jump.png'));
    const im=IMG[name]; if(im&&im.width) ctx.drawImage(im,sx|0,it.y|0,it.w|0,it.h|0);
  }

  for(const f of fires){ const sx=f.x-scrollX; if(sx<-260||sx>vw+260) continue; const im=IMG['tama.png']; if(im&&im.width) ctx.drawImage(im,sx|0,f.y|0,f.w|0,f.h|0); }
  for(const v of villains){ const sx=v.x-scrollX; const im=IMG['viran.png']; if(im&&im.width) ctx.drawImage(im,(sx-60)|0,(v.y-50)|0,120,100); }

  ctx.save(); ctx.translate((RUNX()+player.w/2)|0,(player.y+player.h/2)|0); ctx.rotate(player.tilt); ctx.translate((-player.w/2)|0,(-player.h/2)|0);
  const body=(invincible>0)?'gold.png':player.sprite, pb=IMG[body];
  if(pb&&pb.width){ ctx.drawImage(pb,0,0,player.w|0,player.h|0); if(invincible>0){ const sp=IMG[sparkleFrame?'hoshi1.png':'hoshi2.png']; if(sp&&sp.width) ctx.drawImage(sp,-6,-6,(player.w+12)|0,(player.h+12)|0); } }
  else{ ctx.fillStyle='#0bf'; ctx.fillRect(0,0,player.w|0,player.h|0); }
  ctx.restore();
}

/* ===== Die / GO ===== */
function showGo(){ goMsg.textContent='記録 '+Math.floor(meters)+'m！'; goModal.classList.add('show'); if(goTimer){ clearTimeout(goTimer); } goTimer=setTimeout(()=>{ goModal.classList.remove('show'); openSelect(); }, 20000); }
function die(){ state='gameover'; showGo(); }

/* ===== ゲームロジックの残り ===== */
function addFire(){}

/* ===== Main loop start ===== */
window.addEventListener('error', (e)=>{ fatalMsg.textContent=String(e&&e.message||e); fatal.style.display='flex'; });

/* ----- アイテム／ヴィラン以外は v5.9 と同等の挙動。ここからゲームループ続行 ----- */
let last=0, KMH_PER_PX_LOCAL=KMH_PER_PX; // 参照保持
requestAnimationFrame(gameStep);

})();
</script>
</body>
</html>
